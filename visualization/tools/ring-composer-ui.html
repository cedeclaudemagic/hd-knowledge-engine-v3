<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HD Wheel Ring Composer</title>
  <!-- Characterful typography: Cinzel for headings (classical/mystical), Inter for UI -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Sacred geometry color palette */
      --gold-primary: #D4AF37;
      --gold-light: #F4D35E;
      --gold-dark: #996515;
      --void-deep: #0A0E14;
      --void-mid: #12171F;
      --void-surface: #1A2029;
      --void-elevated: #232A36;
      --cosmic-blue: #2D4A6F;
      --cosmic-teal: #1E4D4D;
      --text-primary: #E8E4DC;
      --text-secondary: #9A9590;
      --text-muted: #5C5852;
      --border-subtle: rgba(212, 175, 55, 0.15);
      --border-accent: rgba(212, 175, 55, 0.4);
      --glow-gold: rgba(212, 175, 55, 0.3);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--void-deep);
      color: var(--text-primary);
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Orchestrated entrance animations */
    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes glowPulse {
      0%, 100% { box-shadow: 0 0 20px var(--glow-gold); }
      50% { box-shadow: 0 0 40px var(--glow-gold), 0 0 60px rgba(212, 175, 55, 0.15); }
    }

    @keyframes subtleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
    }

    /* Left Panel - Controls */
    .controls-panel {
      width: 340px;
      background: linear-gradient(180deg, var(--void-mid) 0%, var(--void-deep) 100%);
      padding: 24px;
      overflow-y: auto;
      border-right: 1px solid var(--border-subtle);
      position: relative;
    }

    .controls-panel::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 1px;
      height: 100%;
      background: linear-gradient(180deg,
        transparent 0%,
        var(--gold-primary) 20%,
        var(--gold-primary) 80%,
        transparent 100%);
      opacity: 0.3;
    }

    /* Custom scrollbar */
    .controls-panel::-webkit-scrollbar {
      width: 6px;
    }
    .controls-panel::-webkit-scrollbar-track {
      background: var(--void-deep);
    }
    .controls-panel::-webkit-scrollbar-thumb {
      background: var(--border-accent);
      border-radius: 3px;
    }
    .controls-panel::-webkit-scrollbar-thumb:hover {
      background: var(--gold-dark);
    }

    h1 {
      font-family: 'Cinzel', serif;
      font-size: 1.4em;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--gold-primary);
      letter-spacing: 0.05em;
      animation: fadeSlideIn 0.6s ease-out;
    }

    .subtitle {
      font-size: 0.75em;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-bottom: 24px;
      animation: fadeSlideIn 0.6s ease-out 0.1s both;
    }

    h2 {
      font-family: 'Cinzel', serif;
      font-size: 0.8em;
      font-weight: 400;
      color: var(--text-secondary);
      margin: 28px 0 14px;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      position: relative;
      padding-left: 12px;
    }

    h2::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 4px;
      background: var(--gold-primary);
      border-radius: 50%;
    }

    /* Ring Cards */
    .ring-card {
      background: var(--void-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .ring-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--gold-primary), transparent);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .ring-card:hover {
      border-color: var(--border-accent);
      transform: translateX(4px);
      background: var(--void-elevated);
    }

    .ring-card:hover::before {
      opacity: 0.5;
    }

    .ring-card.selected {
      border-color: var(--gold-primary);
      background: linear-gradient(135deg, var(--void-elevated) 0%, var(--cosmic-blue) 100%);
      box-shadow: 0 4px 24px rgba(212, 175, 55, 0.15),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .ring-card.selected::before {
      opacity: 1;
    }

    .ring-card.dragging {
      opacity: 0.6;
      border-style: dashed;
      transform: scale(0.98);
    }

    .ring-card.drag-over {
      border-color: var(--gold-light);
      background: var(--cosmic-teal);
      transform: translateX(8px);
    }

    .ring-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      cursor: grab;
      padding: 4px;
      margin: -4px -4px 10px -4px;
      border-radius: 6px;
    }

    .ring-header:hover {
      background: rgba(212, 175, 55, 0.05);
    }

    .ring-header:active {
      cursor: grabbing;
    }

    .ring-name {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 0.95em;
      letter-spacing: 0.02em;
    }

    .ring-position {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65em;
      color: var(--text-muted);
      background: var(--void-deep);
      padding: 4px 10px;
      border-radius: 20px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      border: 1px solid var(--border-subtle);
    }

    .ring-controls {
      display: none;
    }

    .ring-card.selected .ring-controls {
      display: block;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border-subtle);
      animation: fadeSlideIn 0.3s ease-out;
    }

    .control-row {
      margin-bottom: 16px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.75em;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .control-value {
      font-family: 'JetBrains Mono', monospace;
      color: var(--gold-primary);
      font-weight: 500;
    }

    input[type="range"] {
      width: 100%;
      height: 24px;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
      padding: 0;
      margin: 0;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, var(--void-deep), var(--void-elevated));
      border-radius: 2px;
      border: 1px solid var(--border-subtle);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold-primary) 100%);
      border-radius: 50%;
      cursor: grab;
      margin-top: -7px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4),
                  0 0 12px var(--glow-gold);
      border: 2px solid var(--gold-dark);
      transition: all 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.15);
      box-shadow: 0 2px 12px rgba(0,0,0,0.5),
                  0 0 20px var(--glow-gold);
    }

    input[type="range"]::-webkit-slider-thumb:active {
      cursor: grabbing;
      transform: scale(1.2);
    }

    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, var(--void-deep), var(--void-elevated));
      border-radius: 2px;
      border: 1px solid var(--border-subtle);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold-primary) 100%);
      border-radius: 50%;
      cursor: grab;
      border: 2px solid var(--gold-dark);
      box-shadow: 0 2px 8px rgba(0,0,0,0.4),
                  0 0 12px var(--glow-gold);
    }

    input[type="range"]::-moz-range-thumb:active {
      cursor: grabbing;
    }

    input[type="range"]:focus {
      outline: none;
    }

    input[type="range"]:focus::-webkit-slider-thumb {
      box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.25),
                  0 2px 8px rgba(0,0,0,0.4),
                  0 0 16px var(--glow-gold);
    }

    /* Number input fields */
    input[type="number"] {
      width: 60px;
      padding: 4px 8px;
      background: var(--void-deep);
      border: 1px solid var(--border-subtle);
      border-radius: 6px;
      color: var(--gold-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8em;
      text-align: center;
    }

    input[type="number"]:focus {
      outline: none;
      border-color: var(--gold-primary);
      box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
    }

    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      opacity: 1;
    }

    /* Slider row with number input */
    .slider-with-input {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider-with-input input[type="range"] {
      flex: 1;
    }

    /* Order Buttons */
    .order-buttons {
      display: flex;
      gap: 8px;
      margin-top: 14px;
    }

    .order-btn {
      flex: 1;
      padding: 8px 6px;
      border: 1px solid var(--border-subtle);
      background: var(--void-deep);
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.75em;
      font-weight: 500;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .order-btn:hover:not(:disabled) {
      background: var(--void-elevated);
      border-color: var(--border-accent);
      color: var(--gold-primary);
      transform: translateY(-1px);
    }

    .order-btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .order-btn:disabled {
      opacity: 0.25;
      cursor: not-allowed;
    }

    /* Global Controls */
    .global-controls {
      background: var(--void-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      animation: fadeSlideIn 0.6s ease-out 0.2s both;
    }

    /* Action Buttons */
    .actions {
      margin-top: 28px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      animation: fadeSlideIn 0.6s ease-out 0.4s both;
    }

    .action-btn {
      padding: 14px 20px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Cinzel', serif;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .action-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    .action-btn:hover::before {
      left: 100%;
    }

    .action-btn.primary {
      background: linear-gradient(135deg, var(--gold-primary) 0%, var(--gold-dark) 100%);
      color: var(--void-deep);
      box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3);
    }

    .action-btn.primary:hover {
      background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold-primary) 100%);
      box-shadow: 0 6px 24px rgba(212, 175, 55, 0.4);
      transform: translateY(-2px);
    }

    .action-btn.primary:active {
      transform: translateY(0);
    }

    .action-btn.secondary {
      background: var(--void-surface);
      color: var(--text-secondary);
      border: 1px solid var(--border-subtle);
    }

    .action-btn.secondary:hover {
      background: var(--void-elevated);
      border-color: var(--border-accent);
      color: var(--gold-primary);
    }

    /* Right Panel - Preview */
    .preview-panel {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--void-deep);
      position: relative;
      overflow: hidden;
    }

    /* Atmospheric background pattern - behind SVG */
    .preview-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at center, rgba(45, 74, 111, 0.15) 0%, transparent 70%),
        radial-gradient(circle at 20% 80%, rgba(30, 77, 77, 0.1) 0%, transparent 40%),
        radial-gradient(circle at 80% 20%, rgba(212, 175, 55, 0.05) 0%, transparent 40%);
      pointer-events: none;
      z-index: 0;
    }

    /* Subtle grid pattern - behind SVG */
    .preview-panel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        linear-gradient(rgba(212, 175, 55, 0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(212, 175, 55, 0.02) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
      z-index: 0;
    }

    #preview-svg {
      position: absolute;
      z-index: 10;
      filter: drop-shadow(0 0 40px rgba(212, 175, 55, 0.1));
      cursor: grab;
      transition: transform 0.1s ease-out;
    }

    #preview-svg:active {
      cursor: grabbing;
    }

    .zoom-controls {
      position: absolute;
      top: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 20;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      border: 1px solid var(--border-subtle);
      background: rgba(10, 14, 20, 0.9);
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.2em;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      transition: all 0.2s;
    }

    .zoom-btn:hover {
      background: var(--void-elevated);
      border-color: var(--gold-primary);
      color: var(--gold-primary);
    }

    .zoom-level {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7em;
      color: var(--text-muted);
      text-align: center;
      padding: 4px;
      background: rgba(10, 14, 20, 0.8);
      border-radius: 4px;
      border: 1px solid var(--border-subtle);
    }

    .preview-info {
      position: absolute;
      bottom: 24px;
      left: 24px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7em;
      color: var(--text-muted);
      background: rgba(10, 14, 20, 0.8);
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      backdrop-filter: blur(10px);
      z-index: 10;
    }

    .loading-indicator {
      position: absolute;
      top: 24px;
      right: 24px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75em;
      color: var(--gold-primary);
      background: rgba(10, 14, 20, 0.9);
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-accent);
      display: none;
      z-index: 10;
      animation: glowPulse 2s infinite;
    }

    .loading-indicator.visible {
      display: block;
    }

    /* Ring stats */
    .ring-stats {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7em;
      color: var(--text-muted);
      margin-top: 6px;
      padding: 6px 8px;
      background: var(--void-deep);
      border-radius: 4px;
      border: 1px solid var(--border-subtle);
    }

    /* Drag handle */
    .drag-handle {
      cursor: grab;
      color: var(--text-muted);
      margin-right: 10px;
      font-size: 1.1em;
      opacity: 0.6;
      transition: all 0.2s;
    }

    .ring-card:hover .drag-handle {
      opacity: 1;
      color: var(--gold-primary);
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    /* View mode toggle */
    .view-toggle {
      display: flex;
      gap: 6px;
      margin-bottom: 20px;
      animation: fadeSlideIn 0.6s ease-out 0.15s both;
    }

    .view-btn {
      flex: 1;
      padding: 10px 12px;
      border: 1px solid var(--border-subtle);
      background: var(--void-surface);
      color: var(--text-muted);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.75em;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .view-btn.active {
      background: linear-gradient(135deg, var(--gold-primary) 0%, var(--gold-dark) 100%);
      color: var(--void-deep);
      border-color: var(--gold-primary);
      box-shadow: 0 2px 12px rgba(212, 175, 55, 0.3);
    }

    .view-btn:hover:not(.active) {
      border-color: var(--border-accent);
      color: var(--gold-primary);
      background: var(--void-elevated);
    }

    /* Add ring section */
    .add-ring-section h2 {
      margin-top: 24px;
    }

    .ring-options {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .ring-option {
      padding: 8px 14px;
      background: var(--void-surface);
      border: 1px solid;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.75em;
      font-weight: 500;
      transition: all 0.2s;
    }

    .ring-option:hover {
      background: var(--void-elevated);
      transform: scale(1.05);
    }

    /* Delete button special styling */
    .order-btn[style*="color: #ff6b6b"],
    .order-btn[style*="color: rgb(255, 107, 107)"] {
      color: #E57373 !important;
    }

    .order-btn[style*="color: #ff6b6b"]:hover:not(:disabled),
    .order-btn[style*="color: rgb(255, 107, 107)"]:hover:not(:disabled) {
      background: rgba(229, 115, 115, 0.15) !important;
      border-color: rgba(229, 115, 115, 0.4) !important;
    }

    /* Center piece selector */
    .center-piece-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .center-piece-option {
      padding: 10px 16px;
      background: var(--void-surface);
      border: 2px solid var(--border-subtle);
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.8em;
      font-weight: 500;
      color: var(--text-secondary);
      transition: all 0.2s;
    }

    .center-piece-option:hover {
      background: var(--void-elevated);
      border-color: var(--border-accent);
      color: var(--gold-primary);
    }

    .center-piece-option.selected {
      background: linear-gradient(135deg, var(--void-elevated) 0%, var(--cosmic-blue) 100%);
      border-color: var(--gold-primary);
      color: var(--gold-primary);
      box-shadow: 0 2px 12px rgba(212, 175, 55, 0.2);
    }

    /* Usage badge for duplicate rings */
    .usage-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      padding: 0 5px;
      margin-left: 6px;
      background: var(--gold-primary);
      color: var(--void-bg);
      border-radius: 9px;
      font-size: 0.7em;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="controls-panel">
    <h1>Ring Composer</h1>
    <div class="subtitle">Human Design Wheel Builder</div>

    <div class="view-toggle">
      <button class="view-btn active" id="view-actual" onclick="setViewMode('actual')">Actual SVG</button>
      <button class="view-btn" id="view-schematic" onclick="setViewMode('schematic')">Schematic</button>
    </div>

    <div class="global-controls">
      <div class="control-row">
        <div class="control-label">
          <span>Start Radius</span>
          <span class="control-value" id="start-radius-value">500</span>
        </div>
        <input type="range" id="start-radius" min="100" max="800" value="500">
      </div>
      <div class="control-row">
        <div class="control-label">
          <span>Default Gap</span>
          <span class="control-value" id="default-gap-value">2px</span>
        </div>
        <input type="range" id="default-gap" min="0" max="30" value="2">
      </div>
    </div>

    <h2>Center Piece</h2>
    <div id="center-piece-selector" class="center-piece-selector">
      <!-- Center piece options will be inserted here -->
    </div>

    <h2>Rings (drag to reorder)</h2>
    <div id="rings-container">
      <!-- Ring cards will be inserted here -->
    </div>

    <div class="actions">
      <button class="action-btn primary" onclick="exportSVG()">Export SVG</button>
      <button class="action-btn secondary" onclick="resetAll()">Reset All</button>
      <button class="action-btn secondary" onclick="copyConfig()">Copy Config</button>
    </div>
  </div>

  <div class="preview-panel" id="preview-panel">
    <div class="loading-indicator" id="loading">Loading rings...</div>
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
      <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">−</button>
      <button class="zoom-btn" onclick="resetZoom()" title="Reset View">⟲</button>
      <div class="zoom-level" id="zoom-level">100%</div>
    </div>
    <svg id="preview-svg" viewBox="0 0 2000 2000">
      <!-- Preview will be rendered here -->
    </svg>
    <div class="preview-info" id="preview-info">
      Total radius: -- | Scroll to zoom, drag to pan
    </div>
  </div>

  <script>
    // Center piece definitions - these go in the middle of the wheel
    // Only ONE center piece can be selected at a time
    const CENTER_PIECES = {
      none: {
        name: 'None (Empty)',
        color: '#666666',
        svgFile: null,
        radius: 0  // No center piece
      },
      bodygraph: {
        name: 'Bodygraph',
        color: '#FF6B6B',
        svgFile: '../output/generated-bodygraph.svg',
        // Canvas is 1232.9 x 1232.9 with content group having translate(15.2127, 15.2127)
        // The internal center is at viewBox/2 = 601.2374, but after the offset (15.2127)
        // the center IN CANVAS COORDINATES is: 601.2374 + 15.2127 = 616.45
        // Note: The translate is INSIDE the content, so we add it to the internal center
        center: { x: 616.45, y: 616.45 },
        radius: 596.45  // Gate dots are at this radius from center
      }
    };

    // Ring definitions with visual bounds and SVG file paths
    // These values MUST match the actual generator outputs
    const RING_DEFINITIONS = {
      numbers: {
        name: 'Numbers',
        color: '#4ECDC4',
        svgFile: '../output/generated-numbers-ring.svg',
        center: { x: 1657.7978, y: 1657.4867 },
        innerRadius: 1538.587,
        outerRadius: 1648.5514,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      hexagrams: {
        name: 'Hexagrams',
        color: '#45B7D1',
        svgFile: '../output/generated-hexagram-ring.svg',
        center: { x: 1451.344, y: 1451.344 },
        innerRadius: 1334.4257,
        outerRadius: 1451.094,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      codons: {
        name: 'Codon Rings',
        color: '#96CEB4',
        svgFile: '../output/generated-codon-rings-ring.svg',
        center: { x: 1122.0567, y: 1130.6034 },
        // SVG circles: INNERMOST r=838.26, MIDDLE r=1084.37, OUTER r=1108.38
        innerRadius: 838.2597,
        outerRadius: 1084.3718,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() {
          return this.innerRadius - (this.bandWidth * 0.0885);
        },
        get visualOuter() {
          return this.outerRadius + (this.bandWidth * 0.1062);
        }
      },
      genekeys: {
        name: 'Gene Keys',
        color: '#FFEAA7',
        svgFile: '../output/generated-gene-keys-ring.svg',
        // Gene Keys has 3 bands: shadows (inner), gifts (middle), siddhis (outer)
        // Expanded for more breathing room around text
        center: { x: 1985.3602, y: 1985.3602 },
        innerRadius: 1727,        // shadows inner (was 1730.5472)
        outerRadius: 1908,        // siddhis outer (was 1889.9038)
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      iching: {
        name: 'I Ching Names',
        color: '#DDA0DD',
        svgFile: '../output/generated-iching-names-ring.svg',
        center: { x: 1335.2162, y: 1335.2162 },
        innerRadius: 1259.3041,
        outerRadius: 1334.9662,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      gatenames: {
        name: 'Gate Names',
        color: '#87CEEB',
        svgFile: '../output/generated-gate-names-ring.svg',
        center: { x: 1538.3667, y: 1538.3667 },
        innerRadius: 1457.367,
        outerRadius: 1538.0506,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      // === NEW RINGS ADDED ===
      quarters: {
        name: 'Quarters/Trigrams/Faces',
        color: '#9B59B6',
        svgFile: '../output/generated-quarters-trigrams-faces-fifths.svg',
        center: { x: 448.0762, y: 448.3394 },
        innerRadius: 272,
        outerRadius: 448,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      calendar: {
        name: 'Calendar',
        color: '#E67E22',
        svgFile: '../output/generated-calendar-ring.svg',
        // Center matches SVG: cx="826.326" cy="826.326"
        center: { x: 826.326, y: 826.326 },
        innerRadius: 752.81,
        outerRadius: 826.01,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      fullchops: {
        name: 'Full Chops (Yin/Yang)',
        color: '#1ABC9C',
        svgFile: '../output/generated-full-chops-ring.svg',
        center: { x: 1986.0379, y: 1986.0379 },
        // SVG circles: INNER-CENTRE r=1905.2769, OUTER-CENTRE r=1975.0843
        innerRadius: 1905.2769,
        outerRadius: 1975.0843,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      yinchops: {
        name: 'Yin Chops',
        color: '#3498DB',
        svgFile: '../output/generated-yin-chops-ring.svg',
        center: { x: 1986.0379, y: 1986.0379 },
        // SVG circles: INNER-CENTRE r=1905.2769, OUTER-CENTRE r=1975.0843
        innerRadius: 1905.2769,
        outerRadius: 1975.0843,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      yangchops: {
        name: 'Yang Chops',
        color: '#E74C3C',
        svgFile: '../output/generated-yang-chops-ring.svg',
        center: { x: 1986.0379, y: 1986.0379 },
        // SVG circles: INNER-CENTRE r=1905.2769, OUTER-CENTRE r=1975.0843
        innerRadius: 1905.2769,
        outerRadius: 1975.0843,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      crosses: {
        name: 'Incarnation Crosses',
        color: '#F39C12',
        svgFile: '../output/generated-incarnation-crosses-ring.svg',
        center: { x: 2269.7216, y: 2269.9519 },
        innerRadius: 2000.1011,
        outerRadius: 2266.954,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      lines: {
        name: '384 Lines',
        color: '#8E44AD',
        svgFile: '../output/generated-lines-ring.svg',
        center: { x: 6536, y: 6536 },
        innerRadius: 5160,
        outerRadius: 6360,  // Dividers extend to 6360, keynotes at 5487
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 100; }  // Extra for text overflow beyond dividers
      },
      channels: {
        name: 'Channels',
        color: '#27AE60',
        svgFile: '../output/generated-channels-ring.svg',
        center: { x: 6482.5278, y: 6486.1582 },
        innerRadius: 4504.9828,
        outerRadius: 6099,  // Actual outer ring boundary (was incorrectly 6481)
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 20; }  // Small buffer for text
      }
    };

    // Cache for loaded SVG content
    const svgCache = {};

    // Zoom/Pan state
    let viewState = {
      zoom: 1,
      panX: 0,
      panY: 0,
      isPanning: false,
      startPanX: 0,
      startPanY: 0,
      lastMouseX: 0,
      lastMouseY: 0
    };

    // State
    let state = {
      centerPiece: 'bodygraph',  // Selected center piece type ('none', 'bodygraph', etc.)
      rings: [
        { type: 'numbers', scale: 1.0, gapAfter: 2 },      // Hexagram Numbers
        { type: 'quarters', scale: 1.0, gapAfter: 2 },     // Quarters/Trigrams/Faces
        { type: 'calendar', scale: 1.0, gapAfter: 2 },     // Calendar
        { type: 'hexagrams', scale: 1.0, gapAfter: 2 },    // Hexagrams
        { type: 'codons', scale: 1.0, gapAfter: 2 },       // Codons
        { type: 'numbers', scale: 1.0, gapAfter: 2 },      // Hexagram Numbers (duplicate)
        { type: 'iching', scale: 1.0, gapAfter: 2 },       // I Ching Names
        { type: 'gatenames', scale: 1.0, gapAfter: 2 },    // HD Gate Names
        { type: 'yinchops', scale: 1.0, gapAfter: 2 },     // Yin Chops
        { type: 'genekeys', scale: 1.0, gapAfter: 2 },     // Gene Keys
        { type: 'yangchops', scale: 1.0, gapAfter: 2 },    // Yang Chops
        { type: 'crosses', scale: 1.0, gapAfter: 2 },      // Incarnation Crosses
        { type: 'channels', scale: 1.0, gapAfter: 2 },     // Channels
        { type: 'lines', scale: 1.0, gapAfter: 2 }         // 384 Lines
      ],
      selectedIndex: null,
      startRadius: 500,
      defaultGap: 2,
      center: { x: 1000, y: 1000 },
      viewMode: 'actual' // 'actual' or 'schematic'
    };

    // Load SVG file and extract content (works for both rings and center pieces)
    async function loadSVGContent(type, isCenter = false) {
      if (svgCache[type]) {
        return svgCache[type];
      }

      const def = isCenter ? CENTER_PIECES[type] : RING_DEFINITIONS[type];
      if (!def || !def.svgFile) return null;

      console.log(`Loading ${type} from ${def.svgFile}...`);

      try {
        const response = await fetch(def.svgFile);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const svgText = await response.text();
        console.log(`Loaded ${type}: ${svgText.length} bytes`);

        // Extract content between <svg> and </svg>
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgText, 'image/svg+xml');
        const svgElement = doc.querySelector('svg');

        // Check for parse errors
        const parseError = doc.querySelector('parsererror');
        if (parseError) {
          throw new Error(`SVG parse error: ${parseError.textContent}`);
        }

        if (!svgElement) throw new Error('No SVG element found');

        // Get inner content (skip background rect if present)
        let content = '';
        for (const child of svgElement.children) {
          if (child.id !== 'background') {
            content += child.outerHTML;
          }
        }

        console.log(`Extracted ${type} content: ${content.length} chars`);
        svgCache[type] = content;
        return content;
      } catch (error) {
        console.error(`Error loading ${type}:`, error);
        // Show error in UI
        const info = document.getElementById('preview-info');
        info.textContent = `Error: ${error.message}. Run: node visualization/tools/serve.js`;
        info.style.color = '#ff6b6b';
        return null;
      }
    }

    // Preload all ring SVGs and center pieces
    async function preloadRings() {
      const loading = document.getElementById('loading');
      loading.classList.add('visible');

      // Load all rings
      const ringTypes = Object.keys(RING_DEFINITIONS);
      await Promise.all(ringTypes.map(type => loadSVGContent(type, false)));

      // Load all center pieces (except 'none')
      const centerTypes = Object.keys(CENTER_PIECES).filter(t => t !== 'none');
      await Promise.all(centerTypes.map(type => loadSVGContent(type, true)));

      loading.classList.remove('visible');
      renderPreview();
    }

    // Render center piece selector
    function renderCenterPieceSelector() {
      const container = document.getElementById('center-piece-selector');
      container.innerHTML = Object.entries(CENTER_PIECES).map(([type, def]) => `
        <button class="center-piece-option ${state.centerPiece === type ? 'selected' : ''}"
                onclick="selectCenterPiece('${type}')"
                style="${type !== 'none' ? `border-color: ${def.color}` : ''}">
          ${def.name}
        </button>
      `).join('');
    }

    // Select center piece
    async function selectCenterPiece(type) {
      state.centerPiece = type;

      // Load SVG if needed
      if (type !== 'none' && !svgCache[type]) {
        const loading = document.getElementById('loading');
        loading.classList.add('visible');
        await loadSVGContent(type, true);
        loading.classList.remove('visible');
      }

      render();
    }

    // Calculate center piece placement
    function calculateCenterPiecePlacement() {
      if (state.centerPiece === 'none') return null;

      const def = CENTER_PIECES[state.centerPiece];
      if (!def || !def.svgFile) return null;

      // Scale the center piece to fit within startRadius
      const scale = state.startRadius / def.radius;

      // Calculate transform to position center piece at wheel center
      const translateX = state.center.x - (def.center.x * scale);
      const translateY = state.center.y - (def.center.y * scale);

      return {
        type: state.centerPiece,
        name: def.name,
        color: def.color,
        scale,
        radius: def.radius * scale,
        transform: `translate(${translateX.toFixed(4)}, ${translateY.toFixed(4)}) scale(${scale.toFixed(6)})`
      };
    }

    // Calculate snap placements
    function calculatePlacements() {
      const placements = [];
      let currentVisualOuter = state.startRadius;

      for (let i = 0; i < state.rings.length; i++) {
        const ring = state.rings[i];
        const def = RING_DEFINITIONS[ring.type];
        const gap = i === 0 ? 0 : (state.rings[i-1].gapAfter ?? state.defaultGap);

        // Scale to fit at current position
        const targetVisualInner = currentVisualOuter + gap;
        let baseScale = targetVisualInner / def.visualInner;

        // Validate scale to prevent NaN/Infinity
        if (!isFinite(baseScale) || baseScale <= 0) {
          console.warn(`Invalid baseScale for ${def.name}: ${baseScale}, using 1.0`);
          baseScale = 1.0;
        }
        const scale = baseScale * ring.scale;

        const visualInner = def.visualInner * scale;
        const visualOuter = def.visualOuter * scale;
        const innerRadius = def.innerRadius * scale;
        const outerRadius = def.outerRadius * scale;

        // Calculate transform for positioning
        const translateX = state.center.x - (def.center.x * scale);
        const translateY = state.center.y - (def.center.y * scale);

        placements.push({
          type: ring.type,
          name: def.name,
          color: def.color,
          scale,
          innerRadius,
          outerRadius,
          bandWidth: outerRadius - innerRadius,
          visualInner,
          visualOuter,
          visualWidth: visualOuter - visualInner,
          gapAfter: ring.gapAfter ?? state.defaultGap,
          transform: `translate(${translateX.toFixed(4)}, ${translateY.toFixed(4)}) scale(${scale.toFixed(6)})`
        });

        currentVisualOuter = visualOuter;
      }

      return placements;
    }

    // Render preview with actual SVG content
    async function renderPreview() {
      const placements = calculatePlacements();
      const svg = document.getElementById('preview-svg');
      const maxRadius = placements.length > 0
        ? placements[placements.length - 1].visualOuter + 50
        : 500;

      const cx = state.center.x;
      const cy = state.center.y;
      const viewSize = maxRadius * 2 + 100;
      const viewMin = cx - maxRadius - 50;

      svg.setAttribute('viewBox', `${viewMin} ${viewMin} ${viewSize} ${viewSize}`);

      let content = '';

      // Background
      content += `<rect x="${viewMin}" y="${viewMin}" width="${viewSize}" height="${viewSize}" fill="#151E25"/>`;

      // Render center piece first (underneath rings)
      const centerPlacement = calculateCenterPiecePlacement();
      if (centerPlacement && state.viewMode === 'actual') {
        const centerContent = svgCache[centerPlacement.type];
        if (centerContent) {
          console.log(`Rendering center piece: ${centerPlacement.type}, scale: ${centerPlacement.scale.toFixed(4)}, transform: ${centerPlacement.transform}`);
          content += `<g id="center-piece" transform="${centerPlacement.transform}">`;
          content += centerContent;
          content += `</g>`;
        } else {
          console.warn(`Center piece '${centerPlacement.type}' not loaded in cache`);
        }
      } else if (centerPlacement && state.viewMode === 'schematic') {
        // Schematic view for center piece - just show a filled circle
        content += `
          <circle cx="${cx}" cy="${cy}" r="${centerPlacement.radius}"
                  fill="${centerPlacement.color}" fill-opacity="0.2"
                  stroke="${centerPlacement.color}" stroke-width="2"/>
          <text x="${cx}" y="${cy}" fill="${centerPlacement.color}" font-size="14"
                font-family="sans-serif" text-anchor="middle" dominant-baseline="middle">
            ${centerPlacement.name}
          </text>
        `;
      }

      if (state.viewMode === 'actual') {
        // Render actual SVG content
        for (let i = 0; i < placements.length; i++) {
          const p = placements[i];
          const svgContent = svgCache[p.type];

          if (svgContent) {
            const isSelected = i === state.selectedIndex;
            const opacity = isSelected ? 1 : 0.9;

            content += `<g id="${p.type}-ring" transform="${p.transform}" opacity="${opacity}">`;
            content += svgContent;
            content += `</g>`;

            // Add selection highlight
            if (isSelected) {
              content += `
                <circle cx="${cx}" cy="${cy}" r="${p.visualOuter}"
                        fill="none" stroke="${p.color}" stroke-width="3" stroke-opacity="0.8"/>
              `;
            }
          }
        }
      } else {
        // Schematic view
        for (let i = 0; i < placements.length; i++) {
          const p = placements[i];
          const isSelected = i === state.selectedIndex;
          const strokeWidth = isSelected ? 3 : 1;
          const opacity = isSelected ? 1 : 0.7;

          // Main band
          const midRadius = (p.innerRadius + p.outerRadius) / 2;
          content += `
            <circle cx="${cx}" cy="${cy}" r="${midRadius}"
                    fill="none" stroke="${p.color}" stroke-width="${p.bandWidth}"
                    stroke-opacity="${opacity * 0.3}"/>
            <circle cx="${cx}" cy="${cy}" r="${p.innerRadius}"
                    fill="none" stroke="${p.color}" stroke-width="${strokeWidth}" stroke-opacity="${opacity}"/>
            <circle cx="${cx}" cy="${cy}" r="${p.outerRadius}"
                    fill="none" stroke="${p.color}" stroke-width="${strokeWidth}" stroke-opacity="${opacity}"/>
          `;

          // Visual bounds (dashed) when selected
          if (isSelected) {
            content += `
              <circle cx="${cx}" cy="${cy}" r="${p.visualInner}"
                      fill="none" stroke="${p.color}" stroke-width="1" stroke-dasharray="4,4" stroke-opacity="0.4"/>
              <circle cx="${cx}" cy="${cy}" r="${p.visualOuter}"
                      fill="none" stroke="${p.color}" stroke-width="1" stroke-dasharray="4,4" stroke-opacity="0.4"/>
            `;
          }

          // Label
          const labelAngle = -45 * Math.PI / 180;
          const labelX = cx + midRadius * Math.cos(labelAngle);
          const labelY = cy + midRadius * Math.sin(labelAngle);
          content += `
            <text x="${labelX}" y="${labelY}" fill="${p.color}" font-size="14"
                  font-family="sans-serif" text-anchor="middle" opacity="${opacity}">${p.name}</text>
          `;
        }
      }

      // Center marker - using sacred gold color
      const goldColor = '#D4AF37';
      content += `
        <circle cx="${cx}" cy="${cy}" r="6" fill="${goldColor}" opacity="0.9"/>
        <circle cx="${cx}" cy="${cy}" r="3" fill="#F4D35E"/>
        <line x1="${cx-12}" y1="${cy}" x2="${cx+12}" y2="${cy}" stroke="${goldColor}" stroke-width="1" opacity="0.6"/>
        <line x1="${cx}" y1="${cy-12}" x2="${cx}" y2="${cy+12}" stroke="${goldColor}" stroke-width="1" opacity="0.6"/>
      `;

      svg.innerHTML = content;

      // Update info
      const totalRadius = placements.length > 0
        ? placements[placements.length - 1].visualOuter.toFixed(1)
        : 0;
      document.getElementById('preview-info').textContent = `Total radius: ${totalRadius}px | ${state.viewMode === 'actual' ? 'Actual SVG' : 'Schematic'} view`;
    }

    // Set view mode
    function setViewMode(mode) {
      state.viewMode = mode;
      document.getElementById('view-actual').classList.toggle('active', mode === 'actual');
      document.getElementById('view-schematic').classList.toggle('active', mode === 'schematic');
      renderPreview();
    }

    // Render ring cards
    function renderRingCards() {
      const container = document.getElementById('rings-container');
      const placements = calculatePlacements();

      container.innerHTML = state.rings.map((ring, i) => {
        const def = RING_DEFINITIONS[ring.type];
        const p = placements[i];
        const isSelected = i === state.selectedIndex;
        const isFirst = i === 0;
        const isLast = i === state.rings.length - 1;

        return `
          <div class="ring-card ${isSelected ? 'selected' : ''}"
               data-index="${i}"
               onclick="selectRing(${i})">
            <div class="ring-header" data-index="${i}" draggable="true">
              <span class="ring-name" style="color: ${def.color}">
                <span class="drag-handle">⋮⋮</span>
                ${def.name}
              </span>
              <span class="ring-position">${isFirst ? 'innermost' : isLast ? 'outermost' : 'middle'}</span>
            </div>
            <div class="ring-stats">
              Scale: ${(ring.scale * 100).toFixed(0)}% |
              Band: ${p.bandWidth.toFixed(1)}px |
              Gap: ${ring.gapAfter}px
            </div>
            <div class="ring-controls">
              <div class="control-row">
                <div class="control-label">
                  <span>Scale</span>
                </div>
                <div class="slider-with-input">
                  <input type="range" min="20" max="200" value="${ring.scale * 100}"
                         oninput="updateRingScale(${i}, this.value / 100)"
                         onclick="event.stopPropagation()">
                  <input type="number" min="20" max="500" value="${(ring.scale * 100).toFixed(0)}"
                         onchange="updateRingScale(${i}, this.value / 100)"
                         onclick="event.stopPropagation()">%
                </div>
              </div>
              <div class="control-row">
                <div class="control-label">
                  <span>Gap After</span>
                </div>
                <div class="slider-with-input">
                  <input type="range" min="0" max="50" value="${ring.gapAfter}"
                         oninput="updateRingGap(${i}, parseInt(this.value))"
                         onclick="event.stopPropagation()">
                  <input type="number" min="0" max="200" value="${ring.gapAfter}"
                         onchange="updateRingGap(${i}, parseInt(this.value))"
                         onclick="event.stopPropagation()">px
                </div>
              </div>
              <div class="order-buttons">
                <button class="order-btn" onclick="moveRing(${i}, -1); event.stopPropagation();" ${isFirst ? 'disabled' : ''}>
                  ↑ Move In
                </button>
                <button class="order-btn" onclick="moveRing(${i}, 1); event.stopPropagation();" ${isLast ? 'disabled' : ''}>
                  ↓ Move Out
                </button>
                <button class="order-btn" onclick="removeRing(${i}); event.stopPropagation();" style="color: #ff6b6b;">
                  ✕
                </button>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Setup drag and drop
      setupDragAndDrop();

      // Update add ring section
      renderAddRingOptions();
    }

    // Render add ring options
    function renderAddRingOptions() {
      // Count how many times each ring type is used
      const usageCounts = {};
      state.rings.forEach(r => {
        usageCounts[r.type] = (usageCounts[r.type] || 0) + 1;
      });

      // All ring types are always available (duplicates allowed)
      const allTypes = Object.entries(RING_DEFINITIONS);

      // Find or create add ring section
      let addSection = document.querySelector('.add-ring-section');
      if (!addSection) {
        addSection = document.createElement('div');
        addSection.className = 'add-ring-section';
        document.getElementById('rings-container').after(addSection);
      }

      addSection.innerHTML = `
        <h2>Add Ring</h2>
        <div class="ring-options">
          ${allTypes.map(([type, def]) => {
            const count = usageCounts[type] || 0;
            const badge = count > 0 ? `<span class="usage-badge">${count}</span>` : '';
            return `
              <button class="ring-option" onclick="addRing('${type}')"
                      style="border-color: ${def.color}; color: ${def.color}">
                ${def.name}${badge}
              </button>
            `;
          }).join('')}
        </div>
      `;
    }

    // Setup drag and drop - headers are draggable, cards are drop targets
    function setupDragAndDrop() {
      const headers = document.querySelectorAll('.ring-header[draggable="true"]');
      const cards = document.querySelectorAll('.ring-card');

      headers.forEach(header => {
        header.addEventListener('dragstart', (e) => {
          const card = header.closest('.ring-card');
          card.classList.add('dragging');
          e.dataTransfer.setData('text/plain', header.dataset.index);
          e.dataTransfer.effectAllowed = 'move';
        });

        header.addEventListener('dragend', () => {
          const card = header.closest('.ring-card');
          card.classList.remove('dragging');
          document.querySelectorAll('.ring-card').forEach(c => c.classList.remove('drag-over'));
        });
      });

      cards.forEach(card => {
        card.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          const dragging = document.querySelector('.dragging');
          if (dragging !== card) {
            card.classList.add('drag-over');
          }
        });

        card.addEventListener('dragleave', () => {
          card.classList.remove('drag-over');
        });

        card.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = parseInt(card.dataset.index);

          if (fromIndex !== toIndex) {
            const [removed] = state.rings.splice(fromIndex, 1);
            state.rings.splice(toIndex, 0, removed);

            if (state.selectedIndex === fromIndex) {
              state.selectedIndex = toIndex;
            } else if (state.selectedIndex !== null) {
              if (fromIndex < state.selectedIndex && toIndex >= state.selectedIndex) {
                state.selectedIndex--;
              } else if (fromIndex > state.selectedIndex && toIndex <= state.selectedIndex) {
                state.selectedIndex++;
              }
            }

            render();
          }
        });
      });
    }

    // Select a ring
    function selectRing(index) {
      state.selectedIndex = state.selectedIndex === index ? null : index;
      render();
    }

    // Update ring scale
    function updateRingScale(index, scale) {
      state.rings[index].scale = scale;
      render();
    }

    // Update ring gap
    function updateRingGap(index, gap) {
      state.rings[index].gapAfter = gap;
      render();
    }

    // Move ring
    function moveRing(index, direction) {
      const newIndex = index + direction;
      if (newIndex < 0 || newIndex >= state.rings.length) return;

      const [removed] = state.rings.splice(index, 1);
      state.rings.splice(newIndex, 0, removed);
      state.selectedIndex = newIndex;
      render();
    }

    // Remove ring
    function removeRing(index) {
      state.rings.splice(index, 1);
      if (state.selectedIndex === index) {
        state.selectedIndex = null;
      } else if (state.selectedIndex > index) {
        state.selectedIndex--;
      }
      render();
    }

    // Add ring
    async function addRing(type) {
      // Load the SVG if not cached
      if (!svgCache[type]) {
        const loading = document.getElementById('loading');
        loading.classList.add('visible');
        await loadSVGContent(type);
        loading.classList.remove('visible');
      }

      state.rings.push({ type, scale: 1.0, gapAfter: state.defaultGap });
      state.selectedIndex = state.rings.length - 1;
      render();
    }

    // Reset all
    function resetAll() {
      state = {
        centerPiece: 'none',
        rings: [
          { type: 'numbers', scale: 1.0, gapAfter: 0 },
          { type: 'hexagrams', scale: 1.0, gapAfter: 0 },
          { type: 'codons', scale: 1.0, gapAfter: 0 }
        ],
        selectedIndex: null,
        startRadius: 400,
        defaultGap: 0,
        center: { x: 1000, y: 1000 },
        viewMode: state.viewMode
      };
      document.getElementById('start-radius').value = 400;
      document.getElementById('default-gap').value = 0;
      document.getElementById('start-radius-value').textContent = '400';
      document.getElementById('default-gap-value').textContent = '0px';
      render();
    }

    /**
     * Font-specific baseline corrections for Illustrator compatibility.
     * Values are in em units (half cap height).
     */
    const BASELINE_CORRECTIONS = {
      'Herculanum': 0.31,
      'Copperplate': 0.34,
      'Copperplate-Bold': 0.34,
      'Copperplate-Light': 0.34,
      'Copperplate-Bold, Copperplate': 0.34,
      'Copperplate-Light, Copperplate': 0.34,
      'Copperplate, Copperplate-Light': 0.34,
      'default': 0.34
    };

    /**
     * Apply baseline correction for Illustrator export.
     *
     * - Single-line text: adds dy attribute to <text> element
     * - Multiline text: adds baseline correction to FIRST tspan's dy value
     */
    function applyBaselineCorrection(svgContent) {
      let result = svgContent;

      // Handle single-line text (no tspan) - add dy to text element
      result = result.replace(
        /<text([^>]*?)font-family="([^"]+)"([^>]*)>([^<]*)<\/text>/g,
        (match, before, fontFamily, after, content) => {
          if (before.includes('dy=') || after.includes('dy=')) {
            return match;
          }
          const correction = BASELINE_CORRECTIONS[fontFamily] || BASELINE_CORRECTIONS['default'];
          return `<text${before}font-family="${fontFamily}" dy="${correction}em"${after}>${content}</text>`;
        }
      );

      // Handle multiline text - modify first tspan's dy value
      result = result.replace(
        /<text([^>]*?)font-family="([^"]+)"([^>]*)>([\s\S]*?)<\/text>/g,
        (match, before, fontFamily, after, content) => {
          if (!content.includes('<tspan')) {
            return match;
          }

          const correction = BASELINE_CORRECTIONS[fontFamily] || BASELINE_CORRECTIONS['default'];
          let firstTspanProcessed = false;

          // Modify only the first tspan's dy value
          const updatedContent = content.replace(
            /<tspan([^>]*?)dy="([^"]+)"([^>]*)>/g,
            (tspanMatch, tspanBefore, dyValue, tspanAfter) => {
              if (firstTspanProcessed) {
                return tspanMatch; // Leave subsequent tspans unchanged
              }
              firstTspanProcessed = true;

              // Parse existing dy and add correction (convert em to approximate px)
              const existingDy = parseFloat(dyValue);
              // Assuming ~16px base font, 0.34em ≈ 5.4px
              const correctionPx = correction * 16;
              const newDy = existingDy + correctionPx;

              return `<tspan${tspanBefore}dy="${newDy.toFixed(1)}"${tspanAfter}>`;
            }
          );

          return `<text${before}font-family="${fontFamily}"${after}>${updatedContent}</text>`;
        }
      );

      return result;
    }

    // Export SVG - generates actual composited SVG
    function exportSVG() {
      const placements = calculatePlacements();
      const centerPlacement = calculateCenterPiecePlacement();
      const maxRadius = placements.length > 0
        ? placements[placements.length - 1].visualOuter + 50
        : (centerPlacement ? centerPlacement.radius + 50 : 500);
      const cx = state.center.x;
      const cy = state.center.y;
      const viewSize = maxRadius * 2 + 100;
      const viewMin = cx - maxRadius - 50;

      let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     width="${viewSize.toFixed(0)}"
     height="${viewSize.toFixed(0)}"
     viewBox="${viewMin.toFixed(0)} ${viewMin.toFixed(0)} ${viewSize.toFixed(0)} ${viewSize.toFixed(0)}">
  <style>
    text { fill: #FFFFFF; }
    circle, line { stroke: #FFFFFF; }
    #hexagrams rect { fill: #FFFFFF; stroke: none; }
  </style>
  <rect id="background" x="${viewMin.toFixed(0)}" y="${viewMin.toFixed(0)}" width="${viewSize.toFixed(0)}" height="${viewSize.toFixed(0)}" fill="#151E25" stroke="none"/>
`;

      // Add center piece first (underneath rings)
      if (centerPlacement) {
        const centerContent = svgCache[centerPlacement.type];
        if (centerContent) {
          svg += `  <g id="center-piece" transform="${centerPlacement.transform}">\n`;
          svg += `    ${centerContent}\n`;
          svg += `  </g>\n`;
        }
      }

      // Add rings
      for (const p of placements) {
        const svgContent = svgCache[p.type];
        if (svgContent) {
          svg += `  <g id="${p.type}-ring" transform="${p.transform}">\n`;
          svg += `    ${svgContent}\n`;
          svg += `  </g>\n`;
        }
      }

      svg += `</svg>`;

      // Apply baseline correction for Illustrator compatibility
      svg = applyBaselineCorrection(svg);

      // Download
      const blob = new Blob([svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'composed-wheel.svg';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Copy config
    function copyConfig() {
      const config = {
        center: state.center,
        startRadius: state.startRadius,
        defaultGap: state.defaultGap,
        centerPiece: state.centerPiece,
        rings: state.rings.map(r => ({
          type: r.type,
          scale: r.scale,
          gapAfter: r.gapAfter
        }))
      };

      const code = `// Ring Composer Configuration
const config = ${JSON.stringify(config, null, 2)};

// Use with ring-assembler.js:
// const svg = assembler.assembleRings(config);`;

      navigator.clipboard.writeText(code).then(() => {
        alert('Config copied to clipboard!');
      });
    }

    // Main render
    function render() {
      renderCenterPieceSelector();
      renderRingCards();
      renderPreview();
    }

    // Setup global controls
    document.getElementById('start-radius').addEventListener('input', (e) => {
      state.startRadius = parseInt(e.target.value);
      document.getElementById('start-radius-value').textContent = e.target.value;
      render();
    });

    document.getElementById('default-gap').addEventListener('input', (e) => {
      state.defaultGap = parseInt(e.target.value);
      document.getElementById('default-gap-value').textContent = e.target.value + 'px';
      render();
    });

    // ============================================================================
    // ZOOM AND PAN FUNCTIONS
    // ============================================================================

    function updateSvgTransform() {
      const svg = document.getElementById('preview-svg');
      svg.style.transform = `translate(${viewState.panX}px, ${viewState.panY}px) scale(${viewState.zoom})`;
      document.getElementById('zoom-level').textContent = `${Math.round(viewState.zoom * 100)}%`;
    }

    function zoomIn() {
      viewState.zoom = Math.min(viewState.zoom * 1.25, 10);
      updateSvgTransform();
    }

    function zoomOut() {
      viewState.zoom = Math.max(viewState.zoom / 1.25, 0.1);
      updateSvgTransform();
    }

    function resetZoom() {
      viewState.zoom = 1;
      viewState.panX = 0;
      viewState.panY = 0;
      updateSvgTransform();
    }

    function setupZoomPan() {
      const panel = document.getElementById('preview-panel');
      const svg = document.getElementById('preview-svg');

      // Mouse wheel zoom
      panel.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = panel.getBoundingClientRect();
        const mouseX = e.clientX - rect.left - rect.width / 2;
        const mouseY = e.clientY - rect.top - rect.height / 2;

        const oldZoom = viewState.zoom;
        if (e.deltaY < 0) {
          viewState.zoom = Math.min(viewState.zoom * 1.1, 10);
        } else {
          viewState.zoom = Math.max(viewState.zoom / 1.1, 0.1);
        }

        // Zoom towards mouse position
        const zoomRatio = viewState.zoom / oldZoom;
        viewState.panX = mouseX - (mouseX - viewState.panX) * zoomRatio;
        viewState.panY = mouseY - (mouseY - viewState.panY) * zoomRatio;

        updateSvgTransform();
      }, { passive: false });

      // Pan with mouse drag
      svg.addEventListener('mousedown', (e) => {
        if (e.button === 0) {  // Left click
          viewState.isPanning = true;
          viewState.lastMouseX = e.clientX;
          viewState.lastMouseY = e.clientY;
          svg.style.cursor = 'grabbing';
          svg.style.transition = 'none';
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (viewState.isPanning) {
          const dx = e.clientX - viewState.lastMouseX;
          const dy = e.clientY - viewState.lastMouseY;
          viewState.panX += dx;
          viewState.panY += dy;
          viewState.lastMouseX = e.clientX;
          viewState.lastMouseY = e.clientY;
          updateSvgTransform();
        }
      });

      document.addEventListener('mouseup', () => {
        if (viewState.isPanning) {
          viewState.isPanning = false;
          svg.style.cursor = 'grab';
          svg.style.transition = 'transform 0.1s ease-out';
        }
      });

      // Double-click to reset
      svg.addEventListener('dblclick', () => {
        resetZoom();
      });
    }

    // Simple slider event listener
    function setupSliderListeners() {
      // Nothing needed here - using inline oninput handlers
    }

    // Initial load
    preloadRings().then(() => {
      render();
      setupZoomPan();
      setupSliderListeners();
    });
  </script>
</body>
</html>
