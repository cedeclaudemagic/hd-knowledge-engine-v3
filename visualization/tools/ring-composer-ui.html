<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HD Wheel Ring Composer</title>
  <!-- Characterful typography: Cinzel for headings (classical/mystical), Inter for UI -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Sacred geometry color palette */
      --gold-primary: #D4AF37;
      --gold-light: #F4D35E;
      --gold-dark: #996515;
      --void-deep: #0A0E14;
      --void-mid: #12171F;
      --void-surface: #1A2029;
      --void-elevated: #232A36;
      --cosmic-blue: #2D4A6F;
      --cosmic-teal: #1E4D4D;
      --text-primary: #E8E4DC;
      --text-secondary: #9A9590;
      --text-muted: #5C5852;
      --border-subtle: rgba(212, 175, 55, 0.15);
      --border-accent: rgba(212, 175, 55, 0.4);
      --glow-gold: rgba(212, 175, 55, 0.3);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--void-deep);
      color: var(--text-primary);
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Orchestrated entrance animations */
    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes glowPulse {
      0%, 100% { box-shadow: 0 0 20px var(--glow-gold); }
      50% { box-shadow: 0 0 40px var(--glow-gold), 0 0 60px rgba(212, 175, 55, 0.15); }
    }

    @keyframes subtleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
    }

    /* Left Panel - Controls */
    .controls-panel {
      width: 340px;
      background: linear-gradient(180deg, var(--void-mid) 0%, var(--void-deep) 100%);
      padding: 24px;
      overflow-y: auto;
      border-right: 1px solid var(--border-subtle);
      position: relative;
    }

    .controls-panel::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 1px;
      height: 100%;
      background: linear-gradient(180deg,
        transparent 0%,
        var(--gold-primary) 20%,
        var(--gold-primary) 80%,
        transparent 100%);
      opacity: 0.3;
    }

    /* Custom scrollbar */
    .controls-panel::-webkit-scrollbar {
      width: 6px;
    }
    .controls-panel::-webkit-scrollbar-track {
      background: var(--void-deep);
    }
    .controls-panel::-webkit-scrollbar-thumb {
      background: var(--border-accent);
      border-radius: 3px;
    }
    .controls-panel::-webkit-scrollbar-thumb:hover {
      background: var(--gold-dark);
    }

    h1 {
      font-family: 'Cinzel', serif;
      font-size: 1.4em;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--gold-primary);
      letter-spacing: 0.05em;
      animation: fadeSlideIn 0.6s ease-out;
    }

    .subtitle {
      font-size: 0.75em;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      margin-bottom: 24px;
      animation: fadeSlideIn 0.6s ease-out 0.1s both;
    }

    h2 {
      font-family: 'Cinzel', serif;
      font-size: 0.8em;
      font-weight: 400;
      color: var(--text-secondary);
      margin: 28px 0 14px;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      position: relative;
      padding-left: 12px;
    }

    h2::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 4px;
      background: var(--gold-primary);
      border-radius: 50%;
    }

    /* Ring Cards */
    .ring-card {
      background: var(--void-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .ring-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--gold-primary), transparent);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .ring-card:hover {
      border-color: var(--border-accent);
      transform: translateX(4px);
      background: var(--void-elevated);
    }

    .ring-card:hover::before {
      opacity: 0.5;
    }

    .ring-card.selected {
      border-color: var(--gold-primary);
      background: linear-gradient(135deg, var(--void-elevated) 0%, var(--cosmic-blue) 100%);
      box-shadow: 0 4px 24px rgba(212, 175, 55, 0.15),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .ring-card.selected::before {
      opacity: 1;
    }

    .ring-card.dragging {
      opacity: 0.6;
      border-style: dashed;
      transform: scale(0.98);
    }

    .ring-card.drag-over {
      border-color: var(--gold-light);
      background: var(--cosmic-teal);
      transform: translateX(8px);
    }

    .ring-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      cursor: grab;
      padding: 4px;
      margin: -4px -4px 10px -4px;
      border-radius: 6px;
    }

    .ring-header:hover {
      background: rgba(212, 175, 55, 0.05);
    }

    .ring-header:active {
      cursor: grabbing;
    }

    .ring-name {
      font-family: 'Cinzel', serif;
      font-weight: 600;
      font-size: 0.95em;
      letter-spacing: 0.02em;
    }

    .ring-position {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65em;
      color: var(--text-muted);
      background: var(--void-deep);
      padding: 4px 10px;
      border-radius: 20px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      border: 1px solid var(--border-subtle);
    }

    .ring-controls {
      display: none;
    }

    .ring-card.selected .ring-controls {
      display: block;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border-subtle);
      animation: fadeSlideIn 0.3s ease-out;
    }

    .control-row {
      margin-bottom: 16px;
    }

    .apply-gap-btn {
      margin-top: 8px;
      padding: 6px 12px;
      background: var(--surface-darker);
      border: 1px solid var(--gold-primary);
      color: var(--gold-primary);
      border-radius: 4px;
      font-size: 0.75em;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .apply-gap-btn:hover {
      background: var(--gold-primary);
      color: var(--bg-primary);
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.75em;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .control-value {
      font-family: 'JetBrains Mono', monospace;
      color: var(--gold-primary);
      font-weight: 500;
    }

    input[type="range"] {
      width: 100%;
      height: 24px;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
      padding: 0;
      margin: 0;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, var(--void-deep), var(--void-elevated));
      border-radius: 2px;
      border: 1px solid var(--border-subtle);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold-primary) 100%);
      border-radius: 50%;
      cursor: grab;
      margin-top: -7px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4),
                  0 0 12px var(--glow-gold);
      border: 2px solid var(--gold-dark);
      transition: all 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.15);
      box-shadow: 0 2px 12px rgba(0,0,0,0.5),
                  0 0 20px var(--glow-gold);
    }

    input[type="range"]::-webkit-slider-thumb:active {
      cursor: grabbing;
      transform: scale(1.2);
    }

    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, var(--void-deep), var(--void-elevated));
      border-radius: 2px;
      border: 1px solid var(--border-subtle);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold-primary) 100%);
      border-radius: 50%;
      cursor: grab;
      border: 2px solid var(--gold-dark);
      box-shadow: 0 2px 8px rgba(0,0,0,0.4),
                  0 0 12px var(--glow-gold);
    }

    input[type="range"]::-moz-range-thumb:active {
      cursor: grabbing;
    }

    input[type="range"]:focus {
      outline: none;
    }

    input[type="range"]:focus::-webkit-slider-thumb {
      box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.25),
                  0 2px 8px rgba(0,0,0,0.4),
                  0 0 16px var(--glow-gold);
    }

    /* Number input fields */
    input[type="number"] {
      width: 60px;
      padding: 4px 8px;
      background: var(--void-deep);
      border: 1px solid var(--border-subtle);
      border-radius: 6px;
      color: var(--gold-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8em;
      text-align: center;
    }

    input[type="number"]:focus {
      outline: none;
      border-color: var(--gold-primary);
      box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
    }

    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      opacity: 1;
    }

    /* Slider row with number input */
    .slider-with-input {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider-with-input input[type="range"] {
      flex: 1;
    }

    /* Order Buttons */
    .order-buttons {
      display: flex;
      gap: 8px;
      margin-top: 14px;
    }

    .order-btn {
      flex: 1;
      padding: 8px 6px;
      border: 1px solid var(--border-subtle);
      background: var(--void-deep);
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.75em;
      font-weight: 500;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .order-btn:hover:not(:disabled) {
      background: var(--void-elevated);
      border-color: var(--border-accent);
      color: var(--gold-primary);
      transform: translateY(-1px);
    }

    .order-btn:active:not(:disabled) {
      transform: translateY(0);
    }

    .order-btn:disabled {
      opacity: 0.25;
      cursor: not-allowed;
    }

    /* Global Controls */
    .global-controls {
      background: var(--void-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      animation: fadeSlideIn 0.6s ease-out 0.2s both;
    }

    /* Action Buttons */
    .actions {
      margin-top: 28px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      animation: fadeSlideIn 0.6s ease-out 0.4s both;
    }

    .action-btn {
      padding: 14px 20px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-family: 'Cinzel', serif;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .action-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    .action-btn:hover::before {
      left: 100%;
    }

    .action-btn.primary {
      background: linear-gradient(135deg, var(--gold-primary) 0%, var(--gold-dark) 100%);
      color: var(--void-deep);
      box-shadow: 0 4px 16px rgba(212, 175, 55, 0.3);
    }

    .action-btn.primary:hover {
      background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold-primary) 100%);
      box-shadow: 0 6px 24px rgba(212, 175, 55, 0.4);
      transform: translateY(-2px);
    }

    .action-btn.primary:active {
      transform: translateY(0);
    }

    .action-btn.secondary {
      background: var(--void-surface);
      color: var(--text-secondary);
      border: 1px solid var(--border-subtle);
    }

    .action-btn.secondary:hover {
      background: var(--void-elevated);
      border-color: var(--border-accent);
      color: var(--gold-primary);
    }

    /* Right Panel - Preview */
    .preview-panel {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--void-deep);
      position: relative;
      overflow: hidden;
    }

    /* Atmospheric background pattern - behind SVG */
    .preview-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at center, rgba(45, 74, 111, 0.15) 0%, transparent 70%),
        radial-gradient(circle at 20% 80%, rgba(30, 77, 77, 0.1) 0%, transparent 40%),
        radial-gradient(circle at 80% 20%, rgba(212, 175, 55, 0.05) 0%, transparent 40%);
      pointer-events: none;
      z-index: 0;
    }

    /* Subtle grid pattern - behind SVG */
    .preview-panel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        linear-gradient(rgba(212, 175, 55, 0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(212, 175, 55, 0.02) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
      z-index: 0;
    }

    #preview-svg {
      position: absolute;
      z-index: 10;
      filter: drop-shadow(0 0 40px rgba(212, 175, 55, 0.1));
      cursor: grab;
      transition: transform 0.1s ease-out;
    }

    #preview-svg:active {
      cursor: grabbing;
    }

    .zoom-controls {
      position: absolute;
      top: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 20;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      border: 1px solid var(--border-subtle);
      background: rgba(10, 14, 20, 0.9);
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.2em;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
      transition: all 0.2s;
    }

    .zoom-btn:hover {
      background: var(--void-elevated);
      border-color: var(--gold-primary);
      color: var(--gold-primary);
    }

    .zoom-level {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7em;
      color: var(--text-muted);
      text-align: center;
      padding: 4px;
      background: rgba(10, 14, 20, 0.8);
      border-radius: 4px;
      border: 1px solid var(--border-subtle);
    }

    .preview-info {
      position: absolute;
      bottom: 24px;
      left: 24px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7em;
      color: var(--text-muted);
      background: rgba(10, 14, 20, 0.8);
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      backdrop-filter: blur(10px);
      z-index: 10;
    }

    .loading-indicator {
      position: absolute;
      top: 24px;
      right: 24px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75em;
      color: var(--gold-primary);
      background: rgba(10, 14, 20, 0.9);
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-accent);
      display: none;
      z-index: 10;
      animation: glowPulse 2s infinite;
    }

    .loading-indicator.visible {
      display: block;
    }

    /* Ring stats */
    .ring-stats {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7em;
      color: var(--text-muted);
      margin-top: 6px;
      padding: 6px 8px;
      background: var(--void-deep);
      border-radius: 4px;
      border: 1px solid var(--border-subtle);
    }

    /* Drag handle */
    .drag-handle {
      cursor: grab;
      color: var(--text-muted);
      margin-right: 10px;
      font-size: 1.1em;
      opacity: 0.6;
      transition: all 0.2s;
    }

    .ring-card:hover .drag-handle {
      opacity: 1;
      color: var(--gold-primary);
    }

    .drag-handle:active {
      cursor: grabbing;
    }

    /* View mode toggle */
    .view-toggle {
      display: flex;
      gap: 6px;
      margin-bottom: 20px;
      animation: fadeSlideIn 0.6s ease-out 0.15s both;
    }

    .view-btn {
      flex: 1;
      padding: 10px 12px;
      border: 1px solid var(--border-subtle);
      background: var(--void-surface);
      color: var(--text-muted);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.75em;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .view-btn.active {
      background: linear-gradient(135deg, var(--gold-primary) 0%, var(--gold-dark) 100%);
      color: var(--void-deep);
      border-color: var(--gold-primary);
      box-shadow: 0 2px 12px rgba(212, 175, 55, 0.3);
    }

    .view-btn:hover:not(.active) {
      border-color: var(--border-accent);
      color: var(--gold-primary);
      background: var(--void-elevated);
    }

    /* Add ring section */
    .add-ring-section h2 {
      margin-top: 24px;
    }

    .ring-options {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .ring-option {
      padding: 8px 14px;
      background: var(--void-surface);
      border: 1px solid;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.75em;
      font-weight: 500;
      transition: all 0.2s;
    }

    .ring-option:hover {
      background: var(--void-elevated);
      transform: scale(1.05);
    }

    /* Delete button special styling */
    .order-btn[style*="color: #ff6b6b"],
    .order-btn[style*="color: rgb(255, 107, 107)"] {
      color: #E57373 !important;
    }

    .order-btn[style*="color: #ff6b6b"]:hover:not(:disabled),
    .order-btn[style*="color: rgb(255, 107, 107)"]:hover:not(:disabled) {
      background: rgba(229, 115, 115, 0.15) !important;
      border-color: rgba(229, 115, 115, 0.4) !important;
    }

    /* Center piece selector */
    .center-piece-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .center-piece-option {
      padding: 10px 16px;
      background: var(--void-surface);
      border: 2px solid var(--border-subtle);
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.8em;
      font-weight: 500;
      color: var(--text-secondary);
      transition: all 0.2s;
    }

    .center-piece-option:hover {
      background: var(--void-elevated);
      border-color: var(--border-accent);
      color: var(--gold-primary);
    }

    .center-piece-option.selected {
      background: linear-gradient(135deg, var(--void-elevated) 0%, var(--cosmic-blue) 100%);
      border-color: var(--gold-primary);
      color: var(--gold-primary);
      box-shadow: 0 2px 12px rgba(212, 175, 55, 0.2);
    }

    /* Usage badge for duplicate rings */
    .usage-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      padding: 0 5px;
      margin-left: 6px;
      background: var(--gold-primary);
      color: var(--void-bg);
      border-radius: 9px;
      font-size: 0.7em;
      font-weight: 600;
    }

    /* Branding controls */
    .branding-section {
      background: var(--void-surface);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .branding-toggle {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .branding-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--gold-primary);
    }

    .branding-toggle label {
      color: var(--gold-primary);
      font-weight: 500;
      cursor: pointer;
    }

    .branding-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .branding-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .branding-field.full-width {
      grid-column: 1 / -1;
    }

    .branding-field label {
      font-size: 0.75em;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .branding-field select {
      padding: 8px 10px;
      background: var(--void-deep);
      border: 1px solid var(--border-subtle);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 0.9em;
      cursor: pointer;
    }

    .branding-field select:hover {
      border-color: var(--gold-primary);
    }

    .branding-field select:focus {
      outline: none;
      border-color: var(--gold-primary);
      box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
    }

    .branding-preview {
      margin-top: 12px;
      padding: 10px;
      background: var(--void-deep);
      border-radius: 8px;
      font-family: monospace;
      font-size: 0.8em;
      color: var(--text-secondary);
      text-align: center;
    }

    .branding-preview .hexagram-display {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 8px;
    }

    .branding-preview .hex-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .branding-preview .hex-label {
      font-size: 0.65em;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .branding-preview .hex-number {
      color: var(--gold-primary);
      font-weight: bold;
    }

    .branding-preview .hex-number.edition {
      color: #fab300;
    }
  </style>
</head>
<body>
  <div class="controls-panel">
    <h1>Ring Composer</h1>
    <div class="subtitle">Human Design Wheel Builder</div>

    <div class="view-toggle">
      <button class="view-btn active" id="view-actual" onclick="setViewMode('actual')">Actual SVG</button>
      <button class="view-btn" id="view-schematic" onclick="setViewMode('schematic')">Schematic</button>
    </div>

    <div class="global-controls">
      <div class="control-row">
        <div class="control-label">
          <span>Start Radius</span>
          <span class="control-value" id="start-radius-value">800</span>
        </div>
        <input type="range" id="start-radius" min="100" max="1000" value="800">
      </div>
      <div class="control-row">
        <div class="control-label">
          <span>Default Gap</span>
          <span class="control-value" id="default-gap-value">2px</span>
        </div>
        <input type="range" id="default-gap" min="0" max="30" value="2">
        <button id="apply-default-gap" class="apply-gap-btn" title="Apply to all rings">Apply All</button>
      </div>
      <div class="control-row">
        <div class="control-label">
          <span>Export Padding</span>
          <span class="control-value" id="export-padding-value">288px</span>
        </div>
        <input type="range" id="export-padding" min="0" max="500" value="288">
      </div>
    </div>

    <h2>Center Piece</h2>
    <div id="center-piece-selector" class="center-piece-selector">
      <!-- Center piece options will be inserted here -->
    </div>

    <h2>Rings (drag to reorder)</h2>
    <div id="rings-container">
      <!-- Ring cards will be inserted here -->
    </div>

    <h2>Branding</h2>
    <div class="branding-section">
      <div class="branding-toggle">
        <input type="checkbox" id="branding-enabled" checked onchange="toggleBranding(this.checked)">
        <label for="branding-enabled">Show Logo & Serial Number</label>
      </div>
      <div class="branding-grid" id="branding-controls">
        <div class="branding-field">
          <label for="branding-century">Century</label>
          <select id="branding-century" onchange="updateBranding()"></select>
        </div>
        <div class="branding-field">
          <label for="branding-year">Year</label>
          <select id="branding-year" onchange="updateBranding()"></select>
        </div>
        <div class="branding-field">
          <label for="branding-collection">Collection</label>
          <select id="branding-collection" onchange="updateBranding()"></select>
        </div>
        <div class="branding-field">
          <label for="branding-style">Style</label>
          <select id="branding-style" onchange="updateBranding()"></select>
        </div>
        <div class="branding-field full-width">
          <label for="branding-edition">Edition (Gold)</label>
          <select id="branding-edition" onchange="updateBranding()"></select>
        </div>
      </div>
      <div class="branding-preview" id="branding-preview">
        Serial: <span id="branding-serial-display">20.25.61.2.1</span>
      </div>
    </div>

    <div class="actions">
      <button class="action-btn primary" onclick="exportSVG()">Export SVG</button>
      <button class="action-btn secondary" onclick="resetAll()">Reset All</button>
      <button class="action-btn secondary" onclick="copyConfig()">Copy Config</button>
    </div>
  </div>

  <div class="preview-panel" id="preview-panel">
    <div class="loading-indicator" id="loading">Loading rings...</div>
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
      <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">−</button>
      <button class="zoom-btn" onclick="resetZoom()" title="Reset View">⟲</button>
      <div class="zoom-level" id="zoom-level">100%</div>
    </div>
    <svg id="preview-svg" viewBox="0 0 2000 2000">
      <!-- Preview will be rendered here -->
    </svg>
    <div class="preview-info" id="preview-info">
      Total radius: -- | Scroll to zoom, drag to pan
    </div>
  </div>

  <script>
    // Center piece definitions - these go in the middle of the wheel
    // Only ONE center piece can be selected at a time
    const CENTER_PIECES = {
      none: {
        name: 'None (Empty)',
        color: '#666666',
        svgFile: null,
        radius: 0  // No center piece
      },
      bodygraph088: {
        name: 'Bodygraph (0.88x)',
        color: '#FF6B6B',
        svgFile: '../output/generated-bodygraph-0.88x.svg',
        // Canvas is 1202.4747 x 1202.4747 with no offset
        // Internal center at 601.2374, 601.2374
        center: { x: 601.2374, y: 601.2374 },
        radius: 524.88  // Gate dots at 88% of original radius (596.45 * 0.88)
      },
      bodygraph: {
        name: 'Bodygraph (1.0x)',
        color: '#FF6B6B',
        svgFile: '../output/generated-bodygraph.svg',
        // Canvas is 1232.9 x 1232.9 with content group having translate(15.2127, 15.2127)
        // The internal center is at viewBox/2 = 601.2374, but after the offset (15.2127)
        // the center IN CANVAS COORDINATES is: 601.2374 + 15.2127 = 616.45
        center: { x: 616.45, y: 616.45 },
        radius: 596.45  // Gate dots are at this radius from center
      }
    };

    // Ring definitions with visual bounds and SVG file paths
    // These values MUST match the actual generator outputs
    const RING_DEFINITIONS = {
      numbers: {
        name: 'Numbers',
        color: '#4ECDC4',
        svgFile: '../output/generated-numbers-ring.svg',
        center: { x: 1657.7978, y: 1657.4867 },
        innerRadius: 1538.587,
        outerRadius: 1648.5514,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      hexagrams: {
        name: 'Hexagrams',
        color: '#45B7D1',
        svgFile: '../output/generated-hexagram-ring.svg',
        center: { x: 1451.344, y: 1451.344 },
        innerRadius: 1334.4257,
        outerRadius: 1451.094,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      codons: {
        name: 'Codon Rings',
        color: '#96CEB4',
        svgFile: '../output/generated-codon-rings-ring.svg',
        center: { x: 1122.0567, y: 1130.6034 },
        // SVG circles: INNERMOST r=838.26, MIDDLE r=1084.37, OUTER r=1108.38
        innerRadius: 838.2597,
        outerRadius: 1084.3718,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius; },
        get visualOuter() {
          return this.outerRadius + (this.bandWidth * 0.1062);
        }
      },
      genekeys: {
        name: 'Gene Keys',
        color: '#FFEAA7',
        svgFile: '../output/generated-gene-keys-ring.svg',
        // Gene Keys has 3 bands: shadows (inner), gifts (middle), siddhis (outer)
        // Expanded for more breathing room around text
        center: { x: 1985.3602, y: 1985.3602 },
        innerRadius: 1727,        // shadows inner (was 1730.5472)
        outerRadius: 1908,        // siddhis outer (was 1889.9038)
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      iching: {
        name: 'I Ching Names',
        color: '#DDA0DD',
        svgFile: '../output/generated-iching-names-ring.svg',
        center: { x: 1335.2162, y: 1335.2162 },
        innerRadius: 1259.3041,
        outerRadius: 1334.9662,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      gatenames: {
        name: 'Gate Names',
        color: '#87CEEB',
        svgFile: '../output/generated-gate-names-ring.svg',
        center: { x: 1538.3667, y: 1538.3667 },
        innerRadius: 1457.367,
        outerRadius: 1538.0506,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      // === NEW RINGS ADDED ===
      quarters: {
        name: 'Quarters/Trigrams/Faces',
        color: '#9B59B6',
        svgFile: '../output/generated-quarters-trigrams-faces-fifths.svg',
        center: { x: 448.0762, y: 448.3394 },
        innerRadius: 272,
        outerRadius: 448,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      calendar: {
        name: 'Calendar',
        color: '#E67E22',
        svgFile: '../output/generated-calendar-ring.svg',
        // Center matches SVG: cx="826.326" cy="826.326"
        center: { x: 826.326, y: 826.326 },
        innerRadius: 752.81,
        outerRadius: 826.01,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      fullchops: {
        name: 'Full Chops (Yin/Yang)',
        color: '#1ABC9C',
        svgFile: '../output/generated-full-chops-ring.svg',
        center: { x: 1986.0379, y: 1986.0379 },
        // SVG circles: INNER-CENTRE r=1905.2769, OUTER-CENTRE r=1975.0843
        innerRadius: 1905.2769,
        outerRadius: 1975.0843,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      yinchops: {
        name: 'Yin Chops',
        color: '#3498DB',
        svgFile: '../output/generated-yin-chops-ring.svg',
        center: { x: 1986.0379, y: 1986.0379 },
        // SVG circles: INNER-CENTRE r=1905.2769, OUTER-CENTRE r=1975.0843
        innerRadius: 1905.2769,
        outerRadius: 1975.0843,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      yangchops: {
        name: 'Yang Chops',
        color: '#E74C3C',
        svgFile: '../output/generated-yang-chops-ring.svg',
        center: { x: 1986.0379, y: 1986.0379 },
        // SVG circles: INNER-CENTRE r=1905.2769, OUTER-CENTRE r=1975.0843
        innerRadius: 1905.2769,
        outerRadius: 1975.0843,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      crosses: {
        name: 'Incarnation Crosses',
        color: '#F39C12',
        svgFile: '../output/generated-incarnation-crosses-ring.svg',
        center: { x: 2269.7216, y: 2269.9519 },
        innerRadius: 2000.1011,
        outerRadius: 2266.954,
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 2; }
      },
      lines: {
        name: '384 Lines',
        color: '#8E44AD',
        svgFile: '../output/generated-lines-ring.svg',
        center: { x: 6536, y: 6536 },
        innerRadius: 5160,
        outerRadius: 6360,  // Dividers extend to 6360, keynotes at 5487
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 200; }  // Extra for text overflow beyond dividers (keynotes extend ~150px)
      },
      channels: {
        name: 'Channels',
        color: '#27AE60',
        svgFile: '../output/generated-channels-ring.svg',
        center: { x: 6482.5278, y: 6486.1582 },
        innerRadius: 4504.9828,
        outerRadius: 6099,  // Actual outer ring boundary (was incorrectly 6481)
        get bandWidth() { return this.outerRadius - this.innerRadius; },
        get visualInner() { return this.innerRadius - 2; },
        get visualOuter() { return this.outerRadius + 20; }  // Small buffer for text
      }
    };

    // Branding/Logo overlay definition
    // This is positioned absolutely in the corner, not scaled like rings
    const BRANDING_DEFINITION = {
      name: 'Branding (Logo + Serial)',
      color: '#fab300',
      svgFile: '../output/generated-branding-ring.svg',
      // Original viewBox is 14698x14698
      // Branding is positioned in bottom-right corner at absolute coordinates
      originalViewBox: 14698,
      enabled: true,  // Toggle to show/hide branding
      // Serial number config (1-64 for each hexagram)
      config: {
        century: 20,
        year: 25,
        collection: 61,
        style: 2,
        edition: 1
      }
    };

    // Cache for loaded SVG content
    const svgCache = {};

    // Zoom/Pan state
    let viewState = {
      zoom: 1,
      panX: 0,
      panY: 0,
      isPanning: false,
      startPanX: 0,
      startPanY: 0,
      lastMouseX: 0,
      lastMouseY: 0
    };

    // State
    let state = {
      centerPiece: 'bodygraph',  // Selected center piece type ('none', 'bodygraph088', 'bodygraph', etc.)
      rings: [
        { type: 'numbers', scale: 1.02 },    // Hexagram Numbers
        { type: 'quarters', scale: 1.0 },     // Quarters/Trigrams/Faces
        { type: 'calendar', scale: 1.0 },     // Calendar
        { type: 'hexagrams', scale: 1.0 },    // Hexagrams
        { type: 'codons', scale: 1.0 },       // Codons
        { type: 'numbers', scale: 1.0 },      // Hexagram Numbers (duplicate)
        { type: 'iching', scale: 1.0 },       // I Ching Names
        { type: 'gatenames', scale: 1.0 },    // HD Gate Names
        { type: 'yinchops', scale: 1.0 },     // Yin Chops
        { type: 'genekeys', scale: 1.0 },     // Gene Keys
        { type: 'yangchops', scale: 1.0 },    // Yang Chops
        { type: 'crosses', scale: 1.0 },      // Incarnation Crosses
        { type: 'channels', scale: 1.0 },     // Channels
        { type: 'lines', scale: 0.99 }        // 384 Lines
      ],
      selectedIndex: null,
      startRadius: 800,
      defaultGap: 2,
      center: { x: 1000, y: 1000 },
      viewMode: 'actual', // 'actual' or 'schematic'
      exportPadding: 288  // Extra border padding for export (px)
    };

    // Load SVG file and extract content (works for both rings and center pieces)
    async function loadSVGContent(type, isCenter = false) {
      if (svgCache[type]) {
        return svgCache[type];
      }

      const def = isCenter ? CENTER_PIECES[type] : RING_DEFINITIONS[type];
      if (!def || !def.svgFile) return null;

      console.log(`Loading ${type} from ${def.svgFile}...`);

      try {
        const response = await fetch(def.svgFile);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const svgText = await response.text();
        console.log(`Loaded ${type}: ${svgText.length} bytes`);

        // Extract content between <svg> and </svg>
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgText, 'image/svg+xml');
        const svgElement = doc.querySelector('svg');

        // Check for parse errors
        const parseError = doc.querySelector('parsererror');
        if (parseError) {
          throw new Error(`SVG parse error: ${parseError.textContent}`);
        }

        if (!svgElement) throw new Error('No SVG element found');

        // Get inner content (skip background rect if present)
        let content = '';
        for (const child of svgElement.children) {
          if (child.id !== 'background') {
            content += child.outerHTML;
          }
        }

        console.log(`Extracted ${type} content: ${content.length} chars`);
        svgCache[type] = content;
        return content;
      } catch (error) {
        console.error(`Error loading ${type}:`, error);
        // Show error in UI
        const info = document.getElementById('preview-info');
        info.textContent = `Error: ${error.message}. Run: node visualization/tools/serve.js`;
        info.style.color = '#ff6b6b';
        return null;
      }
    }

    // Preload all ring SVGs and center pieces
    // Load branding SVG - tries to load from file first, falls back to dynamic generation
    async function loadBrandingSVG() {
      if (svgCache['branding']) return svgCache['branding'];

      // First try to load from file
      if (BRANDING_DEFINITION.svgFile) {
        console.log(`Loading branding from ${BRANDING_DEFINITION.svgFile}...`);

        try {
          const response = await fetch(BRANDING_DEFINITION.svgFile);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const text = await response.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(text, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');

          if (!svgEl) {
            throw new Error('No SVG element found');
          }

          // Extract just the inner content (skip the svg wrapper and background)
          // We want the LOGO_and_Serial_Number group
          const brandingGroup = svgEl.querySelector('#LOGO_and_Serial_Number');
          if (brandingGroup) {
            svgCache['branding'] = brandingGroup.outerHTML;
          } else {
            // Fallback to all children except background
            const children = Array.from(svgEl.children)
              .filter(el => el.id !== 'background')
              .map(el => el.outerHTML)
              .join('\n');
            svgCache['branding'] = children;
          }

          console.log(`Loaded branding SVG from file`);
          return svgCache['branding'];
        } catch (err) {
          console.warn(`Failed to load branding from file: ${err.message}, using dynamic generation`);
        }
      }

      // Fallback: generate dynamically using current config
      console.log('Generating branding dynamically...');
      svgCache['branding'] = generateBrandingContent(BRANDING_DEFINITION.config);
      return svgCache['branding'];
    }

    async function preloadRings() {
      const loading = document.getElementById('loading');
      loading.classList.add('visible');

      // Load all rings
      const ringTypes = Object.keys(RING_DEFINITIONS);
      await Promise.all(ringTypes.map(type => loadSVGContent(type, false)));

      // Load all center pieces (except 'none')
      const centerTypes = Object.keys(CENTER_PIECES).filter(t => t !== 'none');
      await Promise.all(centerTypes.map(type => loadSVGContent(type, true)));

      // Load branding overlay
      await loadBrandingSVG();

      loading.classList.remove('visible');
      renderPreview();
    }

    // Render center piece selector
    function renderCenterPieceSelector() {
      const container = document.getElementById('center-piece-selector');
      container.innerHTML = Object.entries(CENTER_PIECES).map(([type, def]) => `
        <button class="center-piece-option ${state.centerPiece === type ? 'selected' : ''}"
                onclick="selectCenterPiece('${type}')"
                style="${type !== 'none' ? `border-color: ${def.color}` : ''}">
          ${def.name}
        </button>
      `).join('');
    }

    // Select center piece
    async function selectCenterPiece(type) {
      state.centerPiece = type;

      // Load SVG if needed
      if (type !== 'none' && !svgCache[type]) {
        const loading = document.getElementById('loading');
        loading.classList.add('visible');
        await loadSVGContent(type, true);
        loading.classList.remove('visible');
      }

      render();
    }

    // Calculate center piece placement
    function calculateCenterPiecePlacement() {
      if (state.centerPiece === 'none') return null;

      const def = CENTER_PIECES[state.centerPiece];
      if (!def || !def.svgFile) return null;

      // Scale the center piece to fit within startRadius
      const scale = state.startRadius / def.radius;

      // Calculate transform to position center piece at wheel center
      const translateX = state.center.x - (def.center.x * scale);
      const translateY = state.center.y - (def.center.y * scale);

      return {
        type: state.centerPiece,
        name: def.name,
        color: def.color,
        scale,
        radius: def.radius * scale,
        transform: `translate(${translateX.toFixed(4)}, ${translateY.toFixed(4)}) scale(${scale.toFixed(6)})`
      };
    }

    // Calculate snap placements
    function calculatePlacements() {
      const placements = [];
      let currentVisualOuter = state.startRadius;

      for (let i = 0; i < state.rings.length; i++) {
        const ring = state.rings[i];
        const def = RING_DEFINITIONS[ring.type];
        const gap = i === 0 ? 0 : (state.rings[i-1].gapAfter ?? state.defaultGap);

        // Scale to fit at current position
        const targetVisualInner = currentVisualOuter + gap;
        let baseScale = targetVisualInner / def.visualInner;

        // Validate scale to prevent NaN/Infinity
        if (!isFinite(baseScale) || baseScale <= 0) {
          console.warn(`Invalid baseScale for ${def.name}: ${baseScale}, using 1.0`);
          baseScale = 1.0;
        }
        const scale = baseScale * ring.scale;

        const visualInner = def.visualInner * scale;
        const visualOuter = def.visualOuter * scale;
        const innerRadius = def.innerRadius * scale;
        const outerRadius = def.outerRadius * scale;

        // Calculate transform for positioning
        const translateX = state.center.x - (def.center.x * scale);
        const translateY = state.center.y - (def.center.y * scale);

        placements.push({
          type: ring.type,
          name: def.name,
          color: def.color,
          scale,
          innerRadius,
          outerRadius,
          bandWidth: outerRadius - innerRadius,
          visualInner,
          visualOuter,
          visualWidth: visualOuter - visualInner,
          gapAfter: ring.gapAfter ?? state.defaultGap,
          transform: `translate(${translateX.toFixed(4)}, ${translateY.toFixed(4)}) scale(${scale.toFixed(6)})`
        });

        currentVisualOuter = visualOuter;
      }

      return placements;
    }

    // Render preview with actual SVG content
    async function renderPreview() {
      const placements = calculatePlacements();
      const svg = document.getElementById('preview-svg');
      const padding = state.exportPadding || 150;
      const maxRadius = placements.length > 0
        ? placements[placements.length - 1].visualOuter + padding
        : 500;

      const cx = state.center.x;
      const cy = state.center.y;
      const viewSize = maxRadius * 2 + padding;
      const viewMin = cx - maxRadius - (padding / 2);

      svg.setAttribute('viewBox', `${viewMin} ${viewMin} ${viewSize} ${viewSize}`);

      let content = '';

      // Background
      content += `<rect x="${viewMin}" y="${viewMin}" width="${viewSize}" height="${viewSize}" fill="#151E25"/>`;

      // Export padding indicator (dashed rectangle showing content area)
      const contentRadius = placements.length > 0 ? placements[placements.length - 1].visualOuter : (state.startRadius || 500);
      const contentMin = cx - contentRadius - 10;
      const contentSize = contentRadius * 2 + 20;
      content += `<rect x="${contentMin}" y="${contentMin}" width="${contentSize}" height="${contentSize}"
                        fill="none" stroke="#fab414" stroke-width="1" stroke-dasharray="10,5" stroke-opacity="0.4"/>`;

      // Render center piece first (underneath rings)
      const centerPlacement = calculateCenterPiecePlacement();
      if (centerPlacement && state.viewMode === 'actual') {
        const centerContent = svgCache[centerPlacement.type];
        if (centerContent) {
          console.log(`Rendering center piece: ${centerPlacement.type}, scale: ${centerPlacement.scale.toFixed(4)}, transform: ${centerPlacement.transform}`);
          content += `<g id="center-piece" transform="${centerPlacement.transform}">`;
          content += centerContent;
          content += `</g>`;
        } else {
          console.warn(`Center piece '${centerPlacement.type}' not loaded in cache`);
        }
      } else if (centerPlacement && state.viewMode === 'schematic') {
        // Schematic view for center piece - just show a filled circle
        content += `
          <circle cx="${cx}" cy="${cy}" r="${centerPlacement.radius}"
                  fill="${centerPlacement.color}" fill-opacity="0.2"
                  stroke="${centerPlacement.color}" stroke-width="2"/>
          <text x="${cx}" y="${cy}" fill="${centerPlacement.color}" font-size="14"
                font-family="sans-serif" text-anchor="middle" dominant-baseline="middle">
            ${centerPlacement.name}
          </text>
        `;
      }

      if (state.viewMode === 'actual') {
        // Render actual SVG content
        for (let i = 0; i < placements.length; i++) {
          const p = placements[i];
          const svgContent = svgCache[p.type];

          if (svgContent) {
            const isSelected = i === state.selectedIndex;
            const opacity = isSelected ? 1 : 0.9;

            content += `<g id="${p.type}-ring" transform="${p.transform}" opacity="${opacity}">`;
            content += svgContent;
            content += `</g>`;

            // Add selection highlight
            if (isSelected) {
              content += `
                <circle cx="${cx}" cy="${cy}" r="${p.visualOuter}"
                        fill="none" stroke="${p.color}" stroke-width="3" stroke-opacity="0.8"/>
              `;
            }
          }
        }
      } else {
        // Schematic view
        for (let i = 0; i < placements.length; i++) {
          const p = placements[i];
          const isSelected = i === state.selectedIndex;
          const strokeWidth = isSelected ? 3 : 1;
          const opacity = isSelected ? 1 : 0.7;

          // Main band
          const midRadius = (p.innerRadius + p.outerRadius) / 2;
          content += `
            <circle cx="${cx}" cy="${cy}" r="${midRadius}"
                    fill="none" stroke="${p.color}" stroke-width="${p.bandWidth}"
                    stroke-opacity="${opacity * 0.3}"/>
            <circle cx="${cx}" cy="${cy}" r="${p.innerRadius}"
                    fill="none" stroke="${p.color}" stroke-width="${strokeWidth}" stroke-opacity="${opacity}"/>
            <circle cx="${cx}" cy="${cy}" r="${p.outerRadius}"
                    fill="none" stroke="${p.color}" stroke-width="${strokeWidth}" stroke-opacity="${opacity}"/>
          `;

          // Visual bounds (dashed) when selected
          if (isSelected) {
            content += `
              <circle cx="${cx}" cy="${cy}" r="${p.visualInner}"
                      fill="none" stroke="${p.color}" stroke-width="1" stroke-dasharray="4,4" stroke-opacity="0.4"/>
              <circle cx="${cx}" cy="${cy}" r="${p.visualOuter}"
                      fill="none" stroke="${p.color}" stroke-width="1" stroke-dasharray="4,4" stroke-opacity="0.4"/>
            `;
          }

          // Label
          const labelAngle = -45 * Math.PI / 180;
          const labelX = cx + midRadius * Math.cos(labelAngle);
          const labelY = cy + midRadius * Math.sin(labelAngle);
          content += `
            <text x="${labelX}" y="${labelY}" fill="${p.color}" font-size="14"
                  font-family="sans-serif" text-anchor="middle" opacity="${opacity}">${p.name}</text>
          `;
        }
      }

      // Center marker - using sacred gold color
      const goldColor = '#D4AF37';
      content += `
        <circle cx="${cx}" cy="${cy}" r="6" fill="${goldColor}" opacity="0.9"/>
        <circle cx="${cx}" cy="${cy}" r="3" fill="#F4D35E"/>
        <line x1="${cx-12}" y1="${cy}" x2="${cx+12}" y2="${cy}" stroke="${goldColor}" stroke-width="1" opacity="0.6"/>
        <line x1="${cx}" y1="${cy-12}" x2="${cx}" y2="${cy+12}" stroke="${goldColor}" stroke-width="1" opacity="0.6"/>
      `;

      // Add branding overlay (logo + serial number) if enabled and in actual view mode
      if (BRANDING_DEFINITION.enabled && svgCache['branding'] && state.viewMode === 'actual') {
        // The branding SVG is designed for 14698x14698 viewBox
        // Scale it to match our composed wheel's viewBox
        const brandingScale = viewSize / BRANDING_DEFINITION.originalViewBox;
        // Translate to align with our viewBox origin
        const brandingTranslate = viewMin;
        content += `<g id="branding" transform="translate(${brandingTranslate.toFixed(4)}, ${brandingTranslate.toFixed(4)}) scale(${brandingScale.toFixed(6)})">`;
        content += svgCache['branding'];
        content += `</g>`;
      }

      svg.innerHTML = content;

      // Update info
      const totalRadius = placements.length > 0
        ? placements[placements.length - 1].visualOuter.toFixed(1)
        : 0;
      document.getElementById('preview-info').textContent = `Total radius: ${totalRadius}px | ${state.viewMode === 'actual' ? 'Actual SVG' : 'Schematic'} view`;
    }

    // Set view mode
    function setViewMode(mode) {
      state.viewMode = mode;
      document.getElementById('view-actual').classList.toggle('active', mode === 'actual');
      document.getElementById('view-schematic').classList.toggle('active', mode === 'schematic');
      renderPreview();
    }

    // Render ring cards
    function renderRingCards() {
      const container = document.getElementById('rings-container');
      const placements = calculatePlacements();

      container.innerHTML = state.rings.map((ring, i) => {
        const def = RING_DEFINITIONS[ring.type];
        const p = placements[i];
        const isSelected = i === state.selectedIndex;
        const isFirst = i === 0;
        const isLast = i === state.rings.length - 1;

        return `
          <div class="ring-card ${isSelected ? 'selected' : ''}"
               data-index="${i}"
               onclick="selectRing(${i})">
            <div class="ring-header" data-index="${i}" draggable="true">
              <span class="ring-name" style="color: ${def.color}">
                <span class="drag-handle">⋮⋮</span>
                ${def.name}
              </span>
              <span class="ring-position">${isFirst ? 'innermost' : isLast ? 'outermost' : 'middle'}</span>
            </div>
            <div class="ring-stats">
              Scale: ${(ring.scale * 100).toFixed(0)}% |
              Band: ${p.bandWidth.toFixed(1)}px |
              Gap: ${ring.gapAfter}px
            </div>
            <div class="ring-controls">
              <div class="control-row">
                <div class="control-label">
                  <span>Scale</span>
                </div>
                <div class="slider-with-input">
                  <input type="range" min="20" max="200" value="${ring.scale * 100}"
                         oninput="updateRingScale(${i}, this.value / 100)"
                         onclick="event.stopPropagation()">
                  <input type="number" min="20" max="500" value="${(ring.scale * 100).toFixed(0)}"
                         onchange="updateRingScale(${i}, this.value / 100)"
                         onclick="event.stopPropagation()">%
                </div>
              </div>
              <div class="control-row">
                <div class="control-label">
                  <span>Gap After</span>
                </div>
                <div class="slider-with-input">
                  <input type="range" min="0" max="50" value="${ring.gapAfter}"
                         oninput="updateRingGap(${i}, parseInt(this.value))"
                         onclick="event.stopPropagation()">
                  <input type="number" min="0" max="200" value="${ring.gapAfter}"
                         onchange="updateRingGap(${i}, parseInt(this.value))"
                         onclick="event.stopPropagation()">px
                </div>
              </div>
              <div class="order-buttons">
                <button class="order-btn" onclick="moveRing(${i}, -1); event.stopPropagation();" ${isFirst ? 'disabled' : ''}>
                  ↑ Move In
                </button>
                <button class="order-btn" onclick="moveRing(${i}, 1); event.stopPropagation();" ${isLast ? 'disabled' : ''}>
                  ↓ Move Out
                </button>
                <button class="order-btn" onclick="removeRing(${i}); event.stopPropagation();" style="color: #ff6b6b;">
                  ✕
                </button>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Setup drag and drop
      setupDragAndDrop();

      // Update add ring section
      renderAddRingOptions();
    }

    // Render add ring options
    function renderAddRingOptions() {
      // Count how many times each ring type is used
      const usageCounts = {};
      state.rings.forEach(r => {
        usageCounts[r.type] = (usageCounts[r.type] || 0) + 1;
      });

      // All ring types are always available (duplicates allowed)
      const allTypes = Object.entries(RING_DEFINITIONS);

      // Find or create add ring section
      let addSection = document.querySelector('.add-ring-section');
      if (!addSection) {
        addSection = document.createElement('div');
        addSection.className = 'add-ring-section';
        document.getElementById('rings-container').after(addSection);
      }

      addSection.innerHTML = `
        <h2>Add Ring</h2>
        <div class="ring-options">
          ${allTypes.map(([type, def]) => {
            const count = usageCounts[type] || 0;
            const badge = count > 0 ? `<span class="usage-badge">${count}</span>` : '';
            return `
              <button class="ring-option" onclick="addRing('${type}')"
                      style="border-color: ${def.color}; color: ${def.color}">
                ${def.name}${badge}
              </button>
            `;
          }).join('')}
        </div>
      `;
    }

    // Setup drag and drop - headers are draggable, cards are drop targets
    function setupDragAndDrop() {
      const headers = document.querySelectorAll('.ring-header[draggable="true"]');
      const cards = document.querySelectorAll('.ring-card');

      headers.forEach(header => {
        header.addEventListener('dragstart', (e) => {
          const card = header.closest('.ring-card');
          card.classList.add('dragging');
          e.dataTransfer.setData('text/plain', header.dataset.index);
          e.dataTransfer.effectAllowed = 'move';
        });

        header.addEventListener('dragend', () => {
          const card = header.closest('.ring-card');
          card.classList.remove('dragging');
          document.querySelectorAll('.ring-card').forEach(c => c.classList.remove('drag-over'));
        });
      });

      cards.forEach(card => {
        card.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          const dragging = document.querySelector('.dragging');
          if (dragging !== card) {
            card.classList.add('drag-over');
          }
        });

        card.addEventListener('dragleave', () => {
          card.classList.remove('drag-over');
        });

        card.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = parseInt(card.dataset.index);

          if (fromIndex !== toIndex) {
            const [removed] = state.rings.splice(fromIndex, 1);
            state.rings.splice(toIndex, 0, removed);

            if (state.selectedIndex === fromIndex) {
              state.selectedIndex = toIndex;
            } else if (state.selectedIndex !== null) {
              if (fromIndex < state.selectedIndex && toIndex >= state.selectedIndex) {
                state.selectedIndex--;
              } else if (fromIndex > state.selectedIndex && toIndex <= state.selectedIndex) {
                state.selectedIndex++;
              }
            }

            render();
          }
        });
      });
    }

    // Select a ring
    function selectRing(index) {
      state.selectedIndex = state.selectedIndex === index ? null : index;
      render();
    }

    // Update ring scale
    function updateRingScale(index, scale) {
      state.rings[index].scale = scale;
      render();
    }

    // Update ring gap
    function updateRingGap(index, gap) {
      state.rings[index].gapAfter = gap;
      render();
    }

    // Move ring
    function moveRing(index, direction) {
      const newIndex = index + direction;
      if (newIndex < 0 || newIndex >= state.rings.length) return;

      const [removed] = state.rings.splice(index, 1);
      state.rings.splice(newIndex, 0, removed);
      state.selectedIndex = newIndex;
      render();
    }

    // Remove ring
    function removeRing(index) {
      state.rings.splice(index, 1);
      if (state.selectedIndex === index) {
        state.selectedIndex = null;
      } else if (state.selectedIndex > index) {
        state.selectedIndex--;
      }
      render();
    }

    // Add ring
    async function addRing(type) {
      // Load the SVG if not cached
      if (!svgCache[type]) {
        const loading = document.getElementById('loading');
        loading.classList.add('visible');
        await loadSVGContent(type);
        loading.classList.remove('visible');
      }

      state.rings.push({ type, scale: 1.0, gapAfter: state.defaultGap });
      state.selectedIndex = state.rings.length - 1;
      render();
    }

    // Reset all
    function resetAll() {
      state = {
        centerPiece: 'none',
        rings: [
          { type: 'numbers', scale: 1.0 },
          { type: 'hexagrams', scale: 1.0 },
          { type: 'codons', scale: 1.0 }
        ],
        selectedIndex: null,
        startRadius: 400,
        defaultGap: 0,
        exportPadding: 150,
        center: { x: 1000, y: 1000 },
        viewMode: state.viewMode
      };
      document.getElementById('start-radius').value = 400;
      document.getElementById('default-gap').value = 0;
      document.getElementById('export-padding').value = 150;
      document.getElementById('start-radius-value').textContent = '400';
      document.getElementById('default-gap-value').textContent = '0px';
      document.getElementById('export-padding-value').textContent = '150px';
      render();
    }

    // ========================================================================
    // BRANDING CONTROLS
    // ========================================================================

    // Initialize branding dropdown options (1-64 for each hexagram)
    function initBrandingControls() {
      const fields = ['century', 'year', 'collection', 'style', 'edition'];

      fields.forEach(field => {
        const select = document.getElementById(`branding-${field}`);
        if (!select) return;

        // Clear existing options
        select.innerHTML = '';

        // Add options 1-64
        for (let i = 1; i <= 64; i++) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = i;
          select.appendChild(option);
        }

        // Set initial value from config
        select.value = BRANDING_DEFINITION.config[field];
      });

      // Update the display
      updateBrandingDisplay();
    }

    // Toggle branding visibility
    function toggleBranding(enabled) {
      BRANDING_DEFINITION.enabled = enabled;
      const controls = document.getElementById('branding-controls');
      const preview = document.getElementById('branding-preview');
      if (controls) controls.style.opacity = enabled ? '1' : '0.4';
      if (preview) preview.style.opacity = enabled ? '1' : '0.4';
      renderPreview();
    }

    // Update branding config from dropdowns
    function updateBranding() {
      const fields = ['century', 'year', 'collection', 'style', 'edition'];

      fields.forEach(field => {
        const select = document.getElementById(`branding-${field}`);
        if (select) {
          BRANDING_DEFINITION.config[field] = parseInt(select.value, 10);
        }
      });

      updateBrandingDisplay();
      regenerateBrandingSVG();
    }

    // Update the serial number display
    function updateBrandingDisplay() {
      const display = document.getElementById('branding-serial-display');
      if (display) {
        const c = BRANDING_DEFINITION.config;
        display.textContent = `${c.century}.${c.year}.${c.collection}.${c.style}.${c.edition}`;
      }
    }

    // Hexagram binary patterns (gate number -> binary string, line 1 to line 6)
    // Generated from HD positioning algorithm - VERIFIED CORRECT
    const HEXAGRAM_BINARIES = {
      1: '111111', 2: '000000', 3: '100010', 4: '010001', 5: '111010', 6: '010111',
      7: '010000', 8: '000010', 9: '111011', 10: '110111', 11: '111000', 12: '000111',
      13: '101111', 14: '111101', 15: '001000', 16: '000100', 17: '100110', 18: '011001',
      19: '110000', 20: '000011', 21: '100101', 22: '101001', 23: '000001', 24: '100000',
      25: '100111', 26: '111001', 27: '100001', 28: '011110', 29: '010010', 30: '101101',
      31: '001110', 32: '011100', 33: '001111', 34: '111100', 35: '000101', 36: '101000',
      37: '101011', 38: '110101', 39: '001010', 40: '010100', 41: '110001', 42: '100011',
      43: '111110', 44: '011111', 45: '000110', 46: '011000', 47: '010110', 48: '011010',
      49: '101110', 50: '011101', 51: '100100', 52: '001001', 53: '001011', 54: '110100',
      55: '101100', 56: '001101', 57: '011011', 58: '110110', 59: '010011', 60: '110010',
      61: '110011', 62: '001100', 63: '101010', 64: '010101'
    };

    // Branding geometry constants - UNIFORM SPACING version
    // All hexagrams have identical height and spacing for consistent appearance
    // All Y coordinates represent the TOP of lines (rect semantics)
    const BRAND_GEOM = {
      lineWidth: 38.75,           // Full width of solid (yang) line
      lineHeight: 3.3214,         // Height of each line
      segmentWidth: 14.7619,      // Width of each broken line segment
      lineSpacing: 14.7619,       // Distance between line TOPs (uniform)
      dotRadius: 3.2292,          // Radius of separator dots
      dotGap: 12,                 // Gap between hexagram edge and dot center
      serial: {
        centerX: 13614.0056,      // Center X for dots
        rightX: 13633.06,         // Right edge of lines
        leftSegmentX: 13594.3105, // Left segment X
        rightSegmentX: 13618.2985,// Right segment X
        // TOP of line 1 (bottommost line) of century hexagram
        line1TopY: 13628.9861
      },
      text: {
        x: 12598.4759,
        y: 13633.2907,
        fontSize: 160.5067,
        scaleX: 0.8
      }
    };

    // Calculate uniform Y positions for the serial number
    // Layout (bottom to top): Century -> dot -> Year -> dot -> Collection -> dot -> Style -> dot -> Edition
    function calculateSerialPositions() {
      const g = BRAND_GEOM;

      // Hexagram dimensions:
      // - 6 lines, each lineHeight tall
      // - 5 gaps between lines, each lineSpacing - lineHeight
      // - Total from line 1 TOP to line 6 BOTTOM: 5 * lineSpacing + lineHeight
      const hexTotalHeight = 5 * g.lineSpacing + g.lineHeight;  // ~77.13px

      // Distance from one hexagram's line 6 TOP to the next hexagram's line 1 TOP
      // = gap above hex + dot diameter + gap below dot
      const sectionGap = g.dotGap + (g.dotRadius * 2) + g.dotGap;

      // Start from bottom (century line 1 TOP)
      const centuryLine1TopY = g.serial.line1TopY;

      // Century line 6 TOP (going up = decreasing Y)
      const centuryLine6TopY = centuryLine1TopY - (5 * g.lineSpacing);

      // Dot between Century and Year (centered in gap)
      const dotBelowYearY = centuryLine6TopY - g.dotGap - g.dotRadius;

      // Year line 1 TOP
      const yearLine1TopY = dotBelowYearY - g.dotRadius - g.dotGap;
      const yearLine6TopY = yearLine1TopY - (5 * g.lineSpacing);

      // Dot between Year and Collection
      const dotBelowCollectionY = yearLine6TopY - g.dotGap - g.dotRadius;

      // Collection line 1 TOP
      const collectionLine1TopY = dotBelowCollectionY - g.dotRadius - g.dotGap;
      const collectionLine6TopY = collectionLine1TopY - (5 * g.lineSpacing);

      // Dot between Collection and Style
      const dotBelowStyleY = collectionLine6TopY - g.dotGap - g.dotRadius;

      // Style line 1 TOP
      const styleLine1TopY = dotBelowStyleY - g.dotRadius - g.dotGap;
      const styleLine6TopY = styleLine1TopY - (5 * g.lineSpacing);

      // Dot between Style and Edition
      const dotBelowEditionY = styleLine6TopY - g.dotGap - g.dotRadius;

      // Edition line 1 TOP
      const editionLine1TopY = dotBelowEditionY - g.dotRadius - g.dotGap;

      return {
        centuryLine1TopY,
        dotBelowYearY,
        yearLine1TopY,
        dotBelowCollectionY,
        collectionLine1TopY,
        dotBelowStyleY,
        styleLine1TopY,
        dotBelowEditionY,
        editionLine1TopY
      };
    }

    // Generate a single hexagram line SVG
    // IMPORTANT: Y is always the TOP of the line for consistent spacing
    // Both yang (solid) and yin (broken) use rect elements with identical positioning
    function generateHexLine(topY, isYang, fill) {
      const g = BRAND_GEOM;
      const leftX = g.serial.leftSegmentX;
      const rightSegX = g.serial.rightSegmentX;
      const segW = g.segmentWidth;
      const h = g.lineHeight;

      if (isYang) {
        // Solid line: single rectangle spanning full width
        // Left edge at leftSegmentX, width = segmentWidth + gap + segmentWidth
        const fullWidth = g.lineWidth;
        const fullLeftX = g.serial.rightX - fullWidth;
        return `<rect x="${fullLeftX}" y="${topY}" width="${fullWidth}" height="${h}" fill="${fill}"/>`;
      } else {
        // Broken line: two rectangles with gap in middle
        return `<rect x="${leftX}" y="${topY}" width="${segW}" height="${h}" fill="${fill}"/>
        <rect x="${rightSegX}" y="${topY}" width="${segW}" height="${h}" fill="${fill}"/>`;
      }
    }

    // Generate a complete hexagram (6 lines from bottom to top)
    // line1Y is the TOP of line 1 (bottom line), lines go upward from there
    function generateHexagram(gateNumber, line1TopY, fill) {
      const binary = HEXAGRAM_BINARIES[gateNumber] || '000000';
      const g = BRAND_GEOM;
      let lines = '';

      // Lines 1-6: line 1 at bottom, line 6 at top
      // Each line's TOP is spaced by lineSpacing going upward
      for (let i = 0; i < 6; i++) {
        const lineTopY = line1TopY - (i * g.lineSpacing);
        const isYang = binary[i] === '1';
        lines += generateHexLine(lineTopY, isYang, fill) + '\n';
      }
      return lines;
    }

    // Generate the complete branding SVG content dynamically
    function generateBrandingContent(config) {
      const white = '#fff';
      const silver = '#D4D8DC';  // Tinted Silver - for text only
      const gold = '#fab300';
      const pos = calculateSerialPositions();
      const cx = BRAND_GEOM.serial.centerX;
      const r = BRAND_GEOM.dotRadius;

      let svg = `<g id="SERIAL_NUMBER">
        <g id="CENTURY_-_${config.century}">${generateHexagram(config.century, pos.centuryLine1TopY, white)}</g>
        <circle cx="${cx}" cy="${pos.dotBelowYearY}" r="${r}" fill="${white}"/>
        <g id="YEAR_-_${config.year}">${generateHexagram(config.year, pos.yearLine1TopY, white)}</g>
        <circle cx="${cx}" cy="${pos.dotBelowCollectionY}" r="${r}" fill="${white}"/>
        <g id="COLLECTION_-_${config.collection}">${generateHexagram(config.collection, pos.collectionLine1TopY, white)}</g>
        <circle cx="${cx}" cy="${pos.dotBelowStyleY}" r="${r}" fill="${white}"/>
        <g id="STYLE_-_${config.style}">${generateHexagram(config.style, pos.styleLine1TopY, white)}</g>
        <circle cx="${cx}" cy="${pos.dotBelowEditionY}" r="${r}" fill="${white}"/>
        <g id="EDITION_-_${config.edition}">${generateHexagram(config.edition, pos.editionLine1TopY, gold)}</g>
      </g>
      <g id="LOGO">
        <g id="FLOWER">
          <g id="Dandelion">
            <path id="Stem" d="M13295.6257,13591.2822c-155.8768-22.551-156.8047-197.4485-15.1752-227.0327" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13158.7039,13314.5929c.3756-.2346,78.4656,39.0238,121.6523,46.4656" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13201.1308,13295.7236a113.2114,113.2114,0,0,0,17,20.6918c7.3055,6.9978,13.4223,10.9537,35.8012,24.9,13.9074,7.4241,25.2375,14.5533,27.288,16.9456" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13286.8756,13188.1775c0-1.6495-6.84-1.3122-10.5155.8247-18.5239,10.7711-25.7947,49.7854-27.6289,60.2064-9.8959,56.2234,22.6022,98.41,34.2269,106.679" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13299.914,13224.8676c-24.4643,23.4508-27.9188,68.2284-15.2842,129.338" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13352.7314,13207.0117c-.9026,6.5645-.5186,17.7993-7.5427,27.6872-14.8565,20.9138-27.1816,32.627-35.5136,48.0879-7.8206,14.512-20.1482,35.7108-22.5382,71.0587" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13364.3763,13272.6168c-35.8063,30.3435-66.2719,56.01-74.6746,81.1135" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13420.8851,13282.7529c-4.0563-2.1414-14.4656-1.55-24.2172,2.8631-10.7022,4.844-31.3313,25.7215-48.9379,36.9245-21.1074,11.3783-36.5416,16.4857-56.0221,31.4985" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13404.9516,13349.4323c-15.75,3.4569-44.7825-5.2719-79.1755-3.7114-12.2959.558-23.0795,7.53-32.3712,10.5155" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13420.5745,13383.2855c-18.5772-3.3119-48.1689-22.3978-89.2786-25.9795-13.9986-1.22-26.7051,2.1659-37.5259.8248" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13377.0872,13403.3048c-21.9218-17.7-50.0141-31.6134-83.2406-42.3754" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13369.9192,13435.4274c-3.6209-10.98-30.2612-35.491-77.0319-71.8353" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13325.6207,13448.3742c-8.0126-37.8565-18.8462-67.4484-34.6463-82.49" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13300.5789,13472.4335c-2.5861-14.0909-6.2883-29.7124-4.52-46.3863,2.2417-21.1359-2.8405-40.5955-7.55-59.192" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13272.3081,13437.38c2.7849-17.3236,12.5145-43.9356,13.0955-70.1221" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
            <path d="M13227.2838,13447.8948c8.9719-14.7014,19.0267-41.5624,42.1085-67.6881,6.1366-6.9458,11.64-9.6926,13.2432-13.8432" fill="none" stroke="${gold}" stroke-miterlimit="10" stroke-width="3"/>
          </g>
        </g>
      </g>
      <g id="LOGO_TEXT">
        <text transform="translate(${BRAND_GEOM.text.x} ${BRAND_GEOM.text.y}) scale(${BRAND_GEOM.text.scaleX} 1)" font-size="${BRAND_GEOM.text.fontSize}" fill="${silver}" font-family="Kanit-Thin, Kanit" font-weight="200" letter-spacing="-0.006em">uni<tspan x="215.5566" y="0" letter-spacing="-0.071em">q</tspan><tspan x="299.6619" y="0">uenes</tspan><tspan x="707.1814" y="0" letter-spacing="0.11em">s.</tspan><tspan x="837.1911" y="0" letter-spacing="-0.051em">l</tspan><tspan x="865.7605" y="0" letter-spacing="-0.006em">and</tspan></text>
      </g>`;

      return svg;
    }

    // Regenerate the branding SVG with new config
    function regenerateBrandingSVG() {
      const c = BRANDING_DEFINITION.config;
      console.log('Regenerating branding with config:', c);

      // Generate branding content dynamically
      svgCache['branding'] = generateBrandingContent(c);
      renderPreview();
    }

    /**
     * Font-specific baseline corrections for Illustrator compatibility.
     * Values are in em units (half cap height).
     */
    const BASELINE_CORRECTIONS = {
      'Herculanum': 0.31,
      'Copperplate': 0.34,
      'Copperplate-Bold': 0.34,
      'Copperplate-Light': 0.34,
      'Copperplate-Bold, Copperplate': 0.34,
      'Copperplate-Light, Copperplate': 0.34,
      'Copperplate, Copperplate-Light': 0.34,
      'default': 0.34
    };

    /**
     * Apply baseline correction for Illustrator export.
     *
     * - Single-line text: adds dy attribute to <text> element
     * - Multiline text: adds baseline correction to FIRST tspan's dy value
     */
    function applyBaselineCorrection(svgContent) {
      let result = svgContent;

      // Handle single-line text (no tspan) - add dy to text element
      result = result.replace(
        /<text([^>]*?)font-family="([^"]+)"([^>]*)>([^<]*)<\/text>/g,
        (match, before, fontFamily, after, content) => {
          if (before.includes('dy=') || after.includes('dy=')) {
            return match;
          }
          const correction = BASELINE_CORRECTIONS[fontFamily] || BASELINE_CORRECTIONS['default'];
          return `<text${before}font-family="${fontFamily}" dy="${correction}em"${after}>${content}</text>`;
        }
      );

      // Handle multiline text - modify first tspan's dy value
      result = result.replace(
        /<text([^>]*?)font-family="([^"]+)"([^>]*)>([\s\S]*?)<\/text>/g,
        (match, before, fontFamily, after, content) => {
          if (!content.includes('<tspan')) {
            return match;
          }

          const correction = BASELINE_CORRECTIONS[fontFamily] || BASELINE_CORRECTIONS['default'];
          let firstTspanProcessed = false;

          // Modify only the first tspan's dy value
          const updatedContent = content.replace(
            /<tspan([^>]*?)dy="([^"]+)"([^>]*)>/g,
            (tspanMatch, tspanBefore, dyValue, tspanAfter) => {
              if (firstTspanProcessed) {
                return tspanMatch; // Leave subsequent tspans unchanged
              }
              firstTspanProcessed = true;

              // Parse existing dy and add correction (convert em to approximate px)
              const existingDy = parseFloat(dyValue);
              // Assuming ~16px base font, 0.34em ≈ 5.4px
              const correctionPx = correction * 16;
              const newDy = existingDy + correctionPx;

              return `<tspan${tspanBefore}dy="${newDy.toFixed(1)}"${tspanAfter}>`;
            }
          );

          return `<text${before}font-family="${fontFamily}"${after}>${updatedContent}</text>`;
        }
      );

      return result;
    }

    // Export SVG - generates actual composited SVG
    function exportSVG() {
      const placements = calculatePlacements();
      const centerPlacement = calculateCenterPiecePlacement();
      const padding = state.exportPadding || 150;  // Use configurable padding
      const maxRadius = placements.length > 0
        ? placements[placements.length - 1].visualOuter + padding
        : (centerPlacement ? centerPlacement.radius + padding : 500);
      const cx = state.center.x;
      const cy = state.center.y;
      const viewSize = maxRadius * 2 + padding;
      const viewMin = cx - maxRadius - (padding / 2);

      let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     width="${viewSize.toFixed(0)}"
     height="${viewSize.toFixed(0)}"
     viewBox="${viewMin.toFixed(0)} ${viewMin.toFixed(0)} ${viewSize.toFixed(0)} ${viewSize.toFixed(0)}">
  <style>
    text { fill: #FFFFFF; }
    circle, line { stroke: #FFFFFF; }
    #hexagrams rect { fill: #FFFFFF; stroke: none; }
  </style>
  <rect id="background" x="${viewMin.toFixed(0)}" y="${viewMin.toFixed(0)}" width="${viewSize.toFixed(0)}" height="${viewSize.toFixed(0)}" fill="#151E25" stroke="none"/>
`;

      // Add center piece first (underneath rings)
      if (centerPlacement) {
        const centerContent = svgCache[centerPlacement.type];
        if (centerContent) {
          svg += `  <g id="center-piece" transform="${centerPlacement.transform}">\n`;
          svg += `    ${centerContent}\n`;
          svg += `  </g>\n`;
        }
      }

      // Add rings
      for (const p of placements) {
        const svgContent = svgCache[p.type];
        if (svgContent) {
          svg += `  <g id="${p.type}-ring" transform="${p.transform}">\n`;
          svg += `    ${svgContent}\n`;
          svg += `  </g>\n`;
        }
      }

      // Add branding overlay (logo + serial number) if enabled
      if (BRANDING_DEFINITION.enabled && svgCache['branding']) {
        // The branding SVG is designed for 14698x14698 viewBox
        // Scale it to match our composed wheel's viewBox
        const brandingScale = viewSize / BRANDING_DEFINITION.originalViewBox;
        // Translate to align with our viewBox origin
        const brandingTranslate = viewMin;
        svg += `  <g id="branding" transform="translate(${brandingTranslate.toFixed(4)}, ${brandingTranslate.toFixed(4)}) scale(${brandingScale.toFixed(6)})">\n`;
        svg += `    ${svgCache['branding']}\n`;
        svg += `  </g>\n`;
      }

      svg += `</svg>`;

      // Apply baseline correction for Illustrator compatibility
      svg = applyBaselineCorrection(svg);

      // Download
      const blob = new Blob([svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'composed-wheel.svg';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Copy config
    function copyConfig() {
      const config = {
        center: state.center,
        startRadius: state.startRadius,
        defaultGap: state.defaultGap,
        exportPadding: state.exportPadding,
        centerPiece: state.centerPiece,
        rings: state.rings.map(r => ({
          type: r.type,
          scale: r.scale,
          gapAfter: r.gapAfter
        }))
      };

      const code = `// Ring Composer Configuration
const config = ${JSON.stringify(config, null, 2)};

// Use with ring-assembler.js:
// const svg = assembler.assembleRings(config);`;

      navigator.clipboard.writeText(code).then(() => {
        alert('Config copied to clipboard!');
      });
    }

    // Main render
    function render() {
      renderCenterPieceSelector();
      renderRingCards();
      renderPreview();
    }

    // Setup global controls
    document.getElementById('start-radius').addEventListener('input', (e) => {
      state.startRadius = parseInt(e.target.value);
      document.getElementById('start-radius-value').textContent = e.target.value;
      render();
    });

    document.getElementById('default-gap').addEventListener('input', (e) => {
      state.defaultGap = parseInt(e.target.value);
      document.getElementById('default-gap-value').textContent = e.target.value + 'px';
      render();
    });

    document.getElementById('apply-default-gap').addEventListener('click', () => {
      const count = state.rings.length;
      const gap = state.defaultGap;
      if (confirm(`This will set the gap after ALL ${count} rings to ${gap}px.\n\nThis will override any custom gap values you have set.\n\nContinue?`)) {
        state.rings.forEach(ring => {
          ring.gapAfter = gap;
        });
        render();
      }
    });

    document.getElementById('export-padding').addEventListener('input', (e) => {
      state.exportPadding = parseInt(e.target.value);
      document.getElementById('export-padding-value').textContent = e.target.value + 'px';
      renderPreview();  // Only update preview, not full render (prevents flickering)
    });

    // ============================================================================
    // ZOOM AND PAN FUNCTIONS
    // ============================================================================

    function updateSvgTransform() {
      const svg = document.getElementById('preview-svg');
      svg.style.transform = `translate(${viewState.panX}px, ${viewState.panY}px) scale(${viewState.zoom})`;
      document.getElementById('zoom-level').textContent = `${Math.round(viewState.zoom * 100)}%`;
    }

    function zoomIn() {
      viewState.zoom = Math.min(viewState.zoom * 1.25, 10);
      updateSvgTransform();
    }

    function zoomOut() {
      viewState.zoom = Math.max(viewState.zoom / 1.25, 0.1);
      updateSvgTransform();
    }

    function resetZoom() {
      viewState.zoom = 1;
      viewState.panX = 0;
      viewState.panY = 0;
      updateSvgTransform();
    }

    function setupZoomPan() {
      const panel = document.getElementById('preview-panel');
      const svg = document.getElementById('preview-svg');

      // Mouse wheel zoom
      panel.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = panel.getBoundingClientRect();
        const mouseX = e.clientX - rect.left - rect.width / 2;
        const mouseY = e.clientY - rect.top - rect.height / 2;

        const oldZoom = viewState.zoom;
        if (e.deltaY < 0) {
          viewState.zoom = Math.min(viewState.zoom * 1.1, 10);
        } else {
          viewState.zoom = Math.max(viewState.zoom / 1.1, 0.1);
        }

        // Zoom towards mouse position
        const zoomRatio = viewState.zoom / oldZoom;
        viewState.panX = mouseX - (mouseX - viewState.panX) * zoomRatio;
        viewState.panY = mouseY - (mouseY - viewState.panY) * zoomRatio;

        updateSvgTransform();
      }, { passive: false });

      // Pan with mouse drag
      svg.addEventListener('mousedown', (e) => {
        if (e.button === 0) {  // Left click
          viewState.isPanning = true;
          viewState.lastMouseX = e.clientX;
          viewState.lastMouseY = e.clientY;
          svg.style.cursor = 'grabbing';
          svg.style.transition = 'none';
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (viewState.isPanning) {
          const dx = e.clientX - viewState.lastMouseX;
          const dy = e.clientY - viewState.lastMouseY;
          viewState.panX += dx;
          viewState.panY += dy;
          viewState.lastMouseX = e.clientX;
          viewState.lastMouseY = e.clientY;
          updateSvgTransform();
        }
      });

      document.addEventListener('mouseup', () => {
        if (viewState.isPanning) {
          viewState.isPanning = false;
          svg.style.cursor = 'grab';
          svg.style.transition = 'transform 0.1s ease-out';
        }
      });

      // Double-click to reset
      svg.addEventListener('dblclick', () => {
        resetZoom();
      });
    }

    // Simple slider event listener
    function setupSliderListeners() {
      // Nothing needed here - using inline oninput handlers
    }

    // Initial load
    preloadRings().then(() => {
      render();
      setupZoomPan();
      setupSliderListeners();
      initBrandingControls();
    });
  </script>
</body>
</html>
